Index: python/test/Makefile.am
===================================================================
--- python/test/Makefile.am	(révision 1842)
+++ python/test/Makefile.am	(copie de travail)
@@ -175,6 +175,7 @@
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_ComposedDistribution_large.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_Beta_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_BetaFactory_std.atpy
+PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_Burr_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_ChiSquare_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_ChiSquareFactory_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_ClaytonCopula_std.atpy
@@ -455,6 +456,7 @@
 PYTHONINSTALLCHECK_PROGS += t_Beta_std.py
 PYTHONINSTALLCHECK_PROGS += t_BetaFactory_std.py
 PYTHONINSTALLCHECK_PROGS += t_ChiSquare_std.py
+PYTHONINSTALLCHECK_PROGS += t_Burr_std.py
 PYTHONINSTALLCHECK_PROGS += t_ChiSquareFactory_std.py
 PYTHONINSTALLCHECK_PROGS += t_ClaytonCopula_std.py
 PYTHONINSTALLCHECK_PROGS += t_ClaytonCopulaFactory_std.py
Index: python/test/python_installcheck_testsuite.at
===================================================================
--- python/test/python_installcheck_testsuite.at	(révision 1842)
+++ python/test/python_installcheck_testsuite.at	(copie de travail)
@@ -153,6 +153,7 @@
 ## Distribution 
 m4_include(t_Beta_std.atpy)
 m4_include(t_BetaFactory_std.atpy)
+m4_include(t_Burr_std.atpy)
 m4_include(t_ChiSquare_std.atpy)
 m4_include(t_ChiSquareFactory_std.atpy)
 m4_include(t_ClaytonCopula_std.atpy)
Index: python/test/t_Burr_std.atpy
===================================================================
--- python/test/t_Burr_std.atpy	(révision 0)
+++ python/test/t_Burr_std.atpy	(révision 0)
@@ -0,0 +1,23 @@
+AT_SETUP([Burr])
+
+AT_KEYWORDS([SolverImplementation Solver Burr])
+
+#AT_TESTED([t_Burr_std.py])
+
+AT_CHECK([python ${examplesdir}/t_Burr_std.py],
+         [0],
+[[Distribution  class=Burr name=Burr dimension=1 c=2.5 k=1.3
+Elliptical =  False
+Continuous =  True
+oneRealization= class=NumericalPoint name=Unnamed dimension=1 values=[1.05677]
+oneSample first= class=NumericalPoint name=Unnamed dimension=1 values=[1.77586]  last= class=NumericalPoint name=Unnamed dimension=1 values=[0.775767]
+mean= class=NumericalPoint name=Unnamed dimension=1 values=[1.06338]
+covariance= class=CovarianceMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[0.65507]
+Point=  class=NumericalPoint name=Unnamed dimension=1 values=[3.7]
+pdf     = 0.0114761536636
+cdf= 0.986438693401
+quantile= class=NumericalPoint name=Unnamed dimension=1 values=[3.7]
+]],
+         [ignore])
+
+AT_CLEANUP
Index: python/test/t_Burr_std.py
===================================================================
--- python/test/t_Burr_std.py	(révision 0)
+++ python/test/t_Burr_std.py	(révision 0)
@@ -0,0 +1,82 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+from openturns import *
+
+TESTPREAMBLE()
+RandomGenerator().SetSeed(0)
+
+try :
+    # Instanciate one distribution object
+    distribution = Burr(2.5, 1.3)
+    print "Distribution ", distribution
+
+    # Is this distribution elliptical ?
+    print "Elliptical = ", distribution.isElliptical()
+
+    # Is this distribution continuous ?
+    print "Continuous = ", distribution.isContinuous()
+
+    # Test for realization of distribution
+    oneRealization = distribution.getRealization()
+    print "oneRealization=", repr(oneRealization)
+
+    # Test for sampling
+    size = 10000
+    oneSample = distribution.getNumericalSample( size )
+    print "oneSample first=", repr(oneSample[0]), " last=", repr(oneSample[size - 1])
+    print "mean=", repr(oneSample.computeMean())
+    print "covariance=", repr(oneSample.computeCovariance())
+
+    # Define a point
+    point = NumericalPoint( distribution.getDimension(), 3.7 )
+    print "Point= ", repr(point)
+
+    # Show PDF and CDF of point
+    eps = 1e-5
+    #DDF = distribution.computeDDF( point )
+    #print "ddf     =", repr(DDF)
+    #print "ddf (FD)=", repr(NumericalPoint(1, (distribution.computePDF( point + NumericalPoint(1, eps) ) - distribution.computePDF( point  + NumericalPoint(1, -eps) )) / (2.0 * eps)))
+    PDF = distribution.computePDF( point )
+    print "pdf     =", PDF
+    #print "pdf (FD)= %.9f" % ( (distribution.computeCDF( point + NumericalPoint(1, eps) ) - distribution.computeCDF( point  + NumericalPoint(1, -eps) )) / (2.0 * eps), )
+    CDF = distribution.computeCDF( point )
+    print "cdf=", CDF
+    #CF = distribution.computeCharacteristicFunction( point[0] )
+    #print "characteristic function=", CF
+    #PDFgr = distribution.computePDFGradient( point )
+    #print "pdf gradient     =", repr(PDFgr)
+    #PDFgrFD = NumericalPoint(1)
+    #PDFgrFD[0] = (Burr(distribution.getNu() + eps).computePDF(point) -
+                  #Burr(distribution.getNu() - eps).computePDF(point)) / (2.0 * eps)
+    #print "pdf gradient (FD)=", repr(PDFgrFD)
+    #CDFgr = distribution.computeCDFGradient( point )
+    #print "cdf gradient     =", repr(CDFgr)
+    #CDFgrFD = NumericalPoint(1)
+    #CDFgrFD[0] = (Burr(distribution.getNu() + eps).computeCDF(point) -
+                  #Burr(distribution.getNu() - eps).computeCDF(point)) / (2.0 * eps)
+    #print "cdf gradient (FD)=", repr(CDFgrFD)
+    quantile = distribution.computeQuantile( CDF )
+    print "quantile=", repr(quantile)
+    #print "cdf(quantile)=", distribution.computeCDF(quantile)
+    #mean = distribution.getMean()
+    #print "mean=", repr(mean)
+    #covariance = distribution.getCovariance()
+    #print "covariance=", repr(covariance)
+    #parameters = distribution.getParametersCollection()
+    #print "parameters=", repr(parameters)
+
+    # Specific to this distribution
+    #nu = distribution.getNu()
+    #print "nu=", nu
+    #standardDeviation = distribution.getStandardDeviation()
+    #print "standard deviation=", repr(standardDeviation)
+    #skewness = distribution.getSkewness()
+    #print "skewness=", repr(skewness)
+    #kurtosis = distribution.getKurtosis()
+    #print "kurtosis=", repr(kurtosis)
+
+except :
+    import sys
+    print "t_Burr_std.py", sys.exc_type, sys.exc_value
+
Index: python/src/uncertainty_model_dist.i
===================================================================
--- python/src/uncertainty_model_dist.i	(révision 1842)
+++ python/src/uncertainty_model_dist.i	(copie de travail)
@@ -42,6 +42,7 @@
 %include DistFunc.i
 %include Beta.i
 %include BetaFactory.i
+%include Burr.i
 %include ChiSquare.i
 %include ChiSquareFactory.i
 %include Epanechnikov.i
Index: python/src/Makefile.am
===================================================================
--- python/src/Makefile.am	(révision 1842)
+++ python/src/Makefile.am	(copie de travail)
@@ -589,6 +589,7 @@
         DistFunc.i \
         Beta.i \
         BetaFactory.i \
+        Burr.i \
         ChiSquare.i \
         ChiSquareFactory.i \
         Epanechnikov.i \
Index: python/src/Burr.i
===================================================================
--- python/src/Burr.i	(révision 0)
+++ python/src/Burr.i	(révision 0)
@@ -0,0 +1,11 @@
+// SWIG file Burr.i
+// Author : $LastChangedBy: dutka $
+// Date : $LastChangedDate: 2009-11-09 17:38:15 +0100 (lun. 09 nov. 2009) $
+// Id : $Id: Burr.i 1403 2009-11-09 16:38:15Z dutka $
+
+%{
+#include "Burr.hxx"
+%}
+
+%include Burr.hxx
+namespace OpenTURNS { namespace Uncertainty { namespace Distribution { %extend Burr { Burr(const Burr & other) { return new OpenTURNS::Uncertainty::Distribution::Burr(other); } } }}}
Index: lib/test/t_Burr_std.cxx
===================================================================
--- lib/test/t_Burr_std.cxx	(révision 0)
+++ lib/test/t_Burr_std.cxx	(révision 0)
@@ -0,0 +1,140 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  t_Burr_std.cxx
+ *  @brief The test file of class Burr for standard methods
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy: dutka $
+ *  @date:   $LastChangedDate: 2010-02-04 16:44:49 +0100 (jeu. 04 févr. 2010) $
+ *  Id:      $Id: t_Burr_std.cxx 1473 2010-02-04 15:44:49Z dutka $
+ */
+#include <iostream>
+#include <sstream>
+#include "OT.hxx"
+#include "OTtestcode.hxx"
+#include "OStream.hxx"
+#include "Burr.hxx"
+#include "NumericalPoint.hxx"
+#include "NumericalSample.hxx"
+
+using namespace OT;
+using namespace OT::Test;
+using namespace OT::Base::Common;
+using namespace OT::Base::Common;
+using namespace OT::Base::Type;
+using namespace OT::Base::Stat;
+using namespace OT::Uncertainty::Distribution;
+
+
+class TestObject : public Burr
+{
+public:
+  explicit TestObject() : Burr(2.5, 1.3) {}
+  explicit TestObject(const String & name) : Burr(2.5, 1.3) {setName(name);}
+  virtual ~TestObject() {}
+};
+
+
+int main(int argc, char *argv[])
+{
+  TESTPREAMBLE;
+  OStream fullprint(std::cout);
+  setRandomGenerator();
+
+  try {
+    // Test basic functionnalities
+    checkClassWithClassName<TestObject>();
+
+    // Test some extra functionnalities
+    checkNameFeature<TestObject>();
+
+    // Instanciate one distribution object
+    Burr distribution(2.5, 1.3);
+    fullprint << "Distribution " << distribution << std::endl;
+
+    // Is this distribution elliptical ?
+    fullprint << "Elliptical = " << (distribution.isElliptical() ? "true" : "false") << std::endl;
+
+    // Is this distribution continuous ?
+    fullprint << "Continuous = " << (distribution.isContinuous() ? "true" : "false") << std::endl;
+
+    // Test for realization of distribution
+    NumericalPoint oneRealization = distribution.getRealization();
+    fullprint << "oneRealization=" << oneRealization << std::endl;
+
+    // Test for sampling
+    UnsignedLong size = 10000;
+    NumericalSample oneSample = distribution.getNumericalSample( size );
+    fullprint << "oneSample first=" << oneSample[0] << " last=" << oneSample[size - 1] << std::endl;
+    fullprint << "mean=" << oneSample.computeMean() << std::endl;
+    fullprint << "covariance=" << oneSample.computeCovariance() << std::endl;
+
+    // Define a point
+    NumericalPoint point( distribution.getDimension(), 3.7 );
+    fullprint << "Point= " << point << std::endl;
+
+    // Show PDF and CDF of point
+//     NumericalScalar eps(1e-5);
+    //NumericalPoint DDF = distribution.computeDDF( point );
+    //fullprint << "ddf     =" << DDF << std::endl;
+    //fullprint << "ddf (FD)=" << NumericalPoint(1, (distribution.computePDF( point + NumericalPoint(1, eps) ) - distribution.computePDF( point  + NumericalPoint(1, -eps) )) / (2.0 * eps)) << std::endl;
+    NumericalScalar PDF = distribution.computePDF( point );
+    fullprint << "pdf     =" << PDF << std::endl;
+    //fullprint << "pdf (FD)=" << (distribution.computeCDF( point + NumericalPoint(1, eps) ) - distribution.computeCDF( point  + NumericalPoint(1, -eps) )) / (2.0 * eps) << std::endl;
+    NumericalScalar CDF = distribution.computeCDF( point );
+    fullprint << "cdf=" << CDF << std::endl;
+//     NumericalComplex CF = distribution.computeCharacteristicFunction( point[0] );
+//     fullprint << "characteristic function=" << CF << std::endl;
+//     NumericalPoint PDFgr = distribution.computePDFGradient( point );
+//     fullprint << "pdf gradient     =" << PDFgr << std::endl;
+//     NumericalPoint PDFgrFD(2);
+//     PDFgrFD[0] = (Burr(distribution.getLambda() + eps, distribution.getGamma()).computePDF(point) - Burr(distribution.getLambda() - eps, distribution.getGamma()).computePDF(point)) / (2.0 * eps);
+//     PDFgrFD[1] = (Burr(distribution.getLambda(), distribution.getGamma() + eps).computePDF(point) - Burr(distribution.getLambda(), distribution.getGamma() - eps).computePDF(point)) / (2.0 * eps);
+//     fullprint << "pdf gradient (FD)=" << PDFgrFD << std::endl;
+//     NumericalPoint CDFgr = distribution.computeCDFGradient( point );
+//     fullprint << "cdf gradient     =" << CDFgr << std::endl;
+//     NumericalPoint CDFgrFD(2);
+//     CDFgrFD[0] = (Burr(distribution.getLambda() + eps, distribution.getGamma()).computeCDF(point) - Burr(distribution.getLambda() - eps, distribution.getGamma()).computeCDF(point)) / (2.0 * eps);
+//     CDFgrFD[1] = (Burr(distribution.getLambda(), distribution.getGamma() + eps).computeCDF(point) - Burr(distribution.getLambda(), distribution.getGamma() - eps).computeCDF(point)) / (2.0 * eps);
+//     fullprint << "cdf gradient (FD)=" << CDFgrFD << std::endl;
+    NumericalPoint quantile = distribution.computeQuantile( CDF);
+    fullprint << "quantile=" << quantile << std::endl;
+//     fullprint << "cdf(quantile)=" << distribution.computeCDF(quantile) << std::endl;
+//     NumericalPoint mean = distribution.getMean();
+//     fullprint << "mean=" << mean << std::endl;
+//     NumericalPoint standardDeviation = distribution.getStandardDeviation();
+//     fullprint << "standard deviation=" << standardDeviation << std::endl;
+//     NumericalPoint skewness = distribution.getSkewness();
+//     fullprint << "skewness=" << skewness << std::endl;
+//     NumericalPoint kurtosis = distribution.getKurtosis();
+//     fullprint << "kurtosis=" << kurtosis << std::endl;
+//     CovarianceMatrix covariance = distribution.getCovariance();
+//     fullprint << "covariance=" << covariance << std::endl;
+//     Burr::NumericalPointWithDescriptionCollection parameters = distribution.getParametersCollection();
+//     fullprint << "parameters=" << parameters << std::endl;
+
+    // Specific to this distribution
+  }
+  catch (TestFailed & ex) {
+    std::cerr << ex << std::endl;
+    return ExitCode::Error;
+  }
+
+
+  return ExitCode::Success;
+}

Modification de propriétés sur lib/test/t_Burr_std.cxx
___________________________________________________________________
Ajouté : svn:executable
   + *

Index: lib/test/check_testsuite.at
===================================================================
--- lib/test/check_testsuite.at	(révision 1842)
+++ lib/test/check_testsuite.at	(copie de travail)
@@ -115,6 +115,7 @@
 # Distribution
 m4_include(t_Beta_std.at)
 m4_include(t_BetaFactory_std.at)
+m4_include(t_Burr_std.at)
 m4_include(t_ChiSquare_std.at)
 m4_include(t_ChiSquareFactory_std.at)
 m4_include(t_ComposedCopula_std.at)
Index: lib/test/Makefile.am
===================================================================
--- lib/test/Makefile.am	(révision 1842)
+++ lib/test/Makefile.am	(copie de travail)
@@ -173,6 +173,7 @@
 ## Distribution
 CHECK_TESTS += $(srcdir)/t_Beta_std.at
 CHECK_TESTS += $(srcdir)/t_BetaFactory_std.at
+CHECK_TESTS += $(srcdir)/t_Burr_std.at
 CHECK_TESTS += $(srcdir)/t_ChiSquare_std.at
 CHECK_TESTS += $(srcdir)/t_ChiSquareFactory_std.at
 CHECK_TESTS += $(srcdir)/t_ComposedCopula_std.at
@@ -406,6 +407,7 @@
 ## Distribution
 CHECK_PROGS += t_Beta_std
 CHECK_PROGS += t_BetaFactory_std
+CHECK_PROGS += t_Burr_std
 CHECK_PROGS += t_ChiSquare_std
 CHECK_PROGS += t_ChiSquareFactory_std
 CHECK_PROGS += t_ComposedCopula_std
@@ -1204,6 +1206,7 @@
 ## Distribution
 t_Beta_std_SOURCES                                                 = t_Beta_std.cxx
 t_BetaFactory_std_SOURCES                                          = t_BetaFactory_std.cxx
+t_Burr_std_SOURCES                                                 = t_Burr_std.cxx
 t_ChiSquare_std_SOURCES                                            = t_ChiSquare_std.cxx
 t_ChiSquareFactory_std_SOURCES                                     = t_ChiSquareFactory_std.cxx
 t_ComposedCopula_std_SOURCES                                       = t_ComposedCopula_std.cxx
Index: lib/test/t_Burr_std.at
===================================================================
--- lib/test/t_Burr_std.at	(révision 0)
+++ lib/test/t_Burr_std.at	(révision 0)
@@ -0,0 +1,39 @@
+AT_SETUP([Burr])
+
+AT_KEYWORDS([std Uncertainty Distribution Burr])
+
+#AT_TESTED([t_Burr_std])
+
+AT_CHECK([t_Burr_std],
+         [0],
+[[Testing class Burr
+checkConstructorAndDestructor()
+checkCopyConstructor()
+streamObject(const T & anObject)
+class=Burr name=Burr dimension=1 c=2.5 k=1.3
+streamObject(const T & anObject)
+class=Burr name=Burr dimension=1 c=2.5 k=1.3
+areSameObjects(const T & firstObject, const T & secondObject)
+areDifferentObjects(const T & firstObject, const T & secondObject)
+checkNameFeature()
+checkNameConstructor()
+streamObject(const T & anObject)
+class=Burr name=myName dimension=1 c=2.5 k=1.3
+checkNameAccessors()
+streamObject(const T & anObject)
+class=Burr name=myNewName dimension=1 c=2.5 k=1.3
+Distribution class=Burr name=Burr dimension=1 c=2.5 k=1.3
+Elliptical = false
+Continuous = true
+oneRealization=class=NumericalPoint name=Unnamed dimension=1 values=[1.05677]
+oneSample first=class=NumericalPoint name=Unnamed dimension=1 values=[1.77586] last=class=NumericalPoint name=Unnamed dimension=1 values=[0.775767]
+mean=class=NumericalPoint name=Unnamed dimension=1 values=[1.06338]
+covariance=class=CovarianceMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[0.65507]
+Point= class=NumericalPoint name=Unnamed dimension=1 values=[3.7]
+pdf     =0.0114762
+cdf=0.986439
+quantile=class=NumericalPoint name=Unnamed dimension=1 values=[3.7]
+]],
+         [ignore])
+
+AT_CLEANUP

Modification de propriétés sur lib/test/t_Burr_std.at
___________________________________________________________________
Ajouté : svn:executable
   + *

Index: lib/include/OTconfig.h.in
===================================================================
--- lib/include/OTconfig.h.in	(révision 1842)
+++ lib/include/OTconfig.h.in	(copie de travail)
@@ -166,6 +166,9 @@
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
Index: lib/src/Uncertainty/Distribution/Burr.hxx
===================================================================
--- lib/src/Uncertainty/Distribution/Burr.hxx	(révision 0)
+++ lib/src/Uncertainty/Distribution/Burr.hxx	(révision 0)
@@ -0,0 +1,173 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  Burr.hxx
+ *  @brief The Burr distribution
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy: keller $
+ *  @date:   $LastChangedDate: 2011-22-03 11:30:00 +0100 (mer. 23 mars 2011) $
+ *  Id:      $Id: Burr.hxx 1473 2010-02-04 15:44:49Z keller $
+ */
+#ifndef OPENTURNS_BURR_HXX
+#define OPENTURNS_BURR_HXX
+
+#include "OTprivate.hxx"
+#include "NonEllipticalDistribution.hxx"
+#include "Exception.hxx"
+
+namespace OpenTURNS {
+
+  namespace Uncertainty {
+
+    namespace Distribution {
+
+
+      /**
+       * @class Burr
+       *
+       * The Burr distribution.
+       */
+      class Burr
+        : public Model::NonEllipticalDistribution
+      {
+        CLASSNAME;
+      public:
+
+        typedef Base::Common::InvalidArgumentException               InvalidArgumentException;
+        typedef Model::NonEllipticalDistribution                     NonEllipticalDistribution;  // required by SWIG
+        typedef NonEllipticalDistribution::NumericalPoint            NumericalPoint;
+        typedef NonEllipticalDistribution::NumericalSample           NumericalSample;
+        typedef NonEllipticalDistribution::CovarianceMatrix          CovarianceMatrix;
+        typedef NonEllipticalDistribution::NumericalPointWithDescriptionCollection  NumericalPointWithDescriptionCollection;
+        typedef NonEllipticalDistribution::NotDefinedException       NotDefinedException;
+        typedef NonEllipticalDistribution::StorageManager            StorageManager;
+
+
+        /** Default constructor */
+        Burr();
+
+        /** Parameters constructor */
+        Burr(const NumericalScalar c,
+             const NumericalScalar k)
+          /* throw(InvalidArgumentException) */;
+
+
+        /** Comparison operator */
+        Bool operator ==(const Burr & other) const;
+
+        /** String converter */
+        String __repr__() const;
+
+
+
+        /* Interface inherited from Distribution */
+        /** Virtual constructor */
+        virtual Burr * clone() const;
+
+        /** Get one realization of the distribution */
+        NumericalPoint getRealization() const;
+
+        /** Get the DDF of the distribution */
+        /*using NonEllipticalDistribution::computeDDF;
+        NumericalPoint computeDDF(const NumericalPoint & point) const;
+
+        /** Get the PDF of the distribution */
+        using NonEllipticalDistribution::computePDF;
+        NumericalScalar computePDF(const NumericalPoint & point) const;
+
+        /** Get the CDF of the distribution */
+        using NonEllipticalDistribution::computeCDF;
+        NumericalScalar computeCDF(const NumericalPoint & point, const Bool tail = false) const;
+
+        /** Get the characteristic function of the distribution, i.e. phi(u) = E(exp(I*u*X)) */
+        /*NumericalComplex computeCharacteristicFunction(const NumericalScalar x,
+                                                       const Bool logScale = false) const;
+
+        /** Get the PDFGradient of the distribution */
+        /*NumericalPoint computePDFGradient(const NumericalPoint & point) const;
+
+        /** Get the CDFGradient of the distribution */
+        /*NumericalPoint computeCDFGradient(const NumericalPoint & point) const;
+
+        /** Get the quantile of the distribution */
+        NumericalScalar computeScalarQuantile(const NumericalScalar prob,
+                                              const Bool tail = false,
+                                              const NumericalScalar precision = DefaultQuantileEpsilon) const;
+
+        /** Get the mean of the distribution */
+        /*NumericalPoint getMean() const /* throw(NotDefinedException) */;
+
+        /** Get the standard deviation of the distribution */
+        /*NumericalPoint getStandardDeviation() const /* throw(NotDefinedException) */;
+
+        /** Get the skewness of the distribution */
+        /*NumericalPoint getSkewness() const /* throw(NotDefinedException) */;
+
+        /** Get the kurtosis of the distribution */
+        /*NumericalPoint getKurtosis() const /* throw(NotDefinedException) */;
+
+        /** Get the covariance of the distribution */
+        /*CovarianceMatrix getCovariance() const /* throw(NotDefinedException) */;
+
+        /** Get the raw moments of the standardized distribution */
+        /*NumericalPoint getStandardMoment(const UnsignedLong n) const;
+
+        /** Parameters value and description accessor */
+        NumericalPointWithDescriptionCollection getParametersCollection() const;
+        using NonEllipticalDistribution::setParametersCollection;
+        void setParametersCollection(const NumericalPointCollection & parametersCollection);
+
+        /* Interface specific to Burr */
+
+        /** C accessor */
+        void setC(const NumericalScalar lambda)
+          /* throw(InvalidArgumentException) */;
+        NumericalScalar getC() const;
+
+        /** K accessor */
+        void setK(const NumericalScalar gamma);
+        NumericalScalar getK() const;
+
+        /** Method save() stores the object through the StorageManager */
+        void save(StorageManager::Advocate & adv) const;
+
+        /** Method load() reloads the object from the StorageManager */
+        void load(StorageManager::Advocate & adv);
+
+      protected:
+
+
+      private:
+
+        /** Compute the numerical range of the distribution given the parameters values */
+//         void computeRange();
+
+        /** The c of the Burr distribution */
+        NumericalScalar c_;
+
+        /** The k of the Burr distribution */
+        NumericalScalar k_;
+
+      }; /* class Burr */
+
+
+    } /* namespace Distribution */
+  } /* namespace Uncertainty */
+} /* namespace OpenTURNS */
+
+#endif /* OPENTURNS_BURR_HXX */

Modification de propriétés sur lib/src/Uncertainty/Distribution/Burr.hxx
___________________________________________________________________
Ajouté : svn:executable
   + *

Index: lib/src/Uncertainty/Distribution/OTDistribution.hxx
===================================================================
--- lib/src/Uncertainty/Distribution/OTDistribution.hxx	(révision 1842)
+++ lib/src/Uncertainty/Distribution/OTDistribution.hxx	(copie de travail)
@@ -29,6 +29,7 @@
 
 #include "Beta.hxx"
 #include "BetaFactory.hxx"
+#include "Burr.hxx"
 #include "ChiSquare.hxx"
 #include "ChiSquareFactory.hxx"
 #include "ClaytonCopula.hxx"
Index: lib/src/Uncertainty/Distribution/Burr.cxx
===================================================================
--- lib/src/Uncertainty/Distribution/Burr.cxx	(révision 0)
+++ lib/src/Uncertainty/Distribution/Burr.cxx	(révision 0)
@@ -0,0 +1,296 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  Burr.cxx
+ *  @brief The Burr distribution
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Publicdistributiolib
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy: keller $
+ *  @date:   @date:   $LastChangedDate: 2011-22-03 11:30:00 +0100 (mer. 23 mars 2011) $
+ *  Id:      $Id: Burr.cxx 1473 2011-22-03 11:30:49Z keller $
+ */
+#include <cmath>
+#include "Burr.hxx"
+#include "SpecFunc.hxx"
+#include "RandomGenerator.hxx"
+#include "PersistentObjectFactory.hxx"
+
+namespace OpenTURNS {
+
+  namespace Uncertainty {
+
+    namespace Distribution {
+
+      typedef Base::Stat::RandomGenerator RandomGenerator;
+
+      CLASSNAMEINIT(Burr);
+
+      static Base::Common::Factory<Burr> RegisteredFactory("Burr");
+
+      /* Default constructor */
+      Burr::Burr()
+        : NonEllipticalDistribution("Burr"),
+          c_(1.0),
+          k_(1.0)
+      {
+        setDimension( 1 );
+        computeRange();
+      }
+
+      /* Parameters constructor */
+      Burr::Burr(const NumericalScalar c,
+                               const NumericalScalar k)
+        /* throw(InvalidArgumentException) */
+        : NonEllipticalDistribution("Burr"),
+          c_(c),
+          k_(k)
+      {
+        // We set the dimension of the Burr distribution
+        setDimension( 1 );
+        computeRange();
+      }
+
+      /* Comparison operator */
+      Bool Burr::operator ==(const Burr & other) const
+      {
+        Bool sameObject = false;
+
+        if (this != &other) { // Other is NOT me, so I have to realize the comparison
+          if ( (c_ == other.c_) && (k_ == other.k_) )
+            sameObject = true;
+
+        } else sameObject = true;
+
+        return sameObject;
+      }
+
+      /* String converter */
+      String Burr::__repr__() const
+      {
+        OSS oss;
+        oss << "class=" << Burr::GetClassName()
+            << " name=" << getName()
+            << " dimension=" << getDimension()
+            << " c=" << c_
+            << " k=" << k_;
+        return oss;
+      }
+
+      /* Virtual constructor */
+      Burr * Burr::clone() const
+      {
+        return new Burr(*this);
+      }
+
+      /* Compute the numerical range of the distribution given the parameters values */
+//       void Burr::computeRange()
+//       {
+// 	const NumericalPoint lowerBound(1, k_);
+// 	const NumericalPoint upperBound(computeUpperBound());
+// 	const Interval::BoolCollection finiteLowerBound(1, true);
+// 	const Interval::BoolCollection finiteUpperBound(1, false);
+// 	setRange(Interval(lowerBound, upperBound, finiteLowerBound, finiteUpperBound));
+//       }
+
+      /* Get one realization of the distribution */
+      Burr::NumericalPoint Burr::getRealization() const
+      {
+        return NumericalPoint(1, computeScalarQuantile(RandomGenerator::Generate()));
+      }
+
+
+      /* Get the DDF of the distribution */
+//       Burr::NumericalPoint Burr::computeDDF(const NumericalPoint & point) const
+//       {
+//         if (point[0] < k_) return NumericalPoint(1, 0.0);
+//         return NumericalPoint(1, -c_ * computePDF(point));
+//       }
+
+
+      /* Get the PDF of the distribution */
+      NumericalScalar Burr::computePDF(const NumericalPoint & point) const
+      {
+        NumericalScalar x(point[0]);
+        if (x < 0.0) return 0.0;
+        return c_ * k_ * exp(log(x) * (c_ - 1.0)) * exp(-log(1.0 + exp(c_ * log(x))) * (k_ + 1.0));
+      }
+
+
+      /* Get the CDF of the distribution */
+      NumericalScalar Burr::computeCDF(const NumericalPoint & point, const Bool tail) const
+      {
+        NumericalScalar x(point[0]);
+        if (x < 0.0) return (tail ? 1.0 : 0.0);
+        if (tail) return exp(-k_ * log(1.0 + exp(c_ * log(x))));
+        return 1.0 - exp(-k_ * log(1.0 + exp(c_ * log(x))));
+      }
+
+      /* Get the characteristic function of the distribution, i.e. phi(u) = E(exp(I*u*X)) */
+//       NumericalComplex Burr::computeCharacteristicFunction(const NumericalScalar x,
+//                                                                   const Bool logScale) const
+//       {
+//         if (logScale) return log(c_) + NumericalComplex(0, -x * k_) - log(NumericalComplex(c_, -x));
+//         return c_ * exp(NumericalComplex(0, -x * k_)) / NumericalComplex(c_, -x);
+//       }
+// 
+//       /* Get the PDFGradient of the distribution */
+//       Burr::NumericalPoint Burr::computePDFGradient(const NumericalPoint & point) const
+//       {
+//         NumericalScalar x(point[0] - k_);
+//         NumericalPoint pdfGradient(2, 0.0);
+//         if (x < 0.0) return pdfGradient;
+//         NumericalScalar expX(exp(-c_ * x));
+//         pdfGradient[0] = (1.0 - c_ * x) * expX;
+//         pdfGradient[1] = c_ * c_ * expX;
+//         return pdfGradient;
+//       }
+// 
+//       /* Get the CDFGradient of the distribution */
+//       Burr::NumericalPoint Burr::computeCDFGradient(const NumericalPoint & point) const
+//       {
+//         NumericalScalar x(point[0] - k_);
+//         NumericalPoint cdfGradient(2, 0.0);
+//         if (x < 0.0) return cdfGradient;
+//         NumericalScalar expX(exp(-c_ * x));
+//         cdfGradient[0] = x * expX;
+//         cdfGradient[1] = -c_ * expX;
+//         return cdfGradient;
+//       }
+// 
+//       /* Get the quantile of the distribution */
+      NumericalScalar Burr::computeScalarQuantile(const NumericalScalar prob,
+							 const Bool tail,
+                                                         const NumericalScalar precision) const
+      {
+	if (tail) return exp( log( exp( -log( prob ) / k_ ) - 1.0) / c_ );
+        return exp( log( exp( -log( 1.0 - prob ) / k_ ) - 1.0) / c_ );
+      }
+
+      /* Get the mean of the distribution */
+/*      Burr::NumericalPoint Burr::getMean() const /* throw(NotDefinedException) */
+//     {
+//        return NumericalPoint(1, k_ + 1.0 / c_);
+//      }*/
+// 
+//       /* Get the standard deviation of the distribution */
+//       Burr::NumericalPoint Burr::getStandardDeviation() const /* throw(NotDefinedException) */
+//       {
+//         return NumericalPoint(1, 1.0 / c_);
+//       }
+// 
+//       /* Get the skewness of the distribution */
+//       Burr::NumericalPoint Burr::getSkewness() const /* throw(NotDefinedException) */
+//       {
+//         return NumericalPoint(1, 2.0);
+//       }
+// 
+//       /* Get the kurtosis of the distribution */
+//       Burr::NumericalPoint Burr::getKurtosis() const /* throw(NotDefinedException) */
+//       {
+//         return NumericalPoint(1, 9.0);
+//       }
+// 
+//       /* Get the covariance of the distribution */
+//       Burr::CovarianceMatrix Burr::getCovariance() const /* throw(NotDefinedException) */
+//       {
+//         CovarianceMatrix covariance(1);
+//         covariance(0, 0) = 1.0 / (c_ * c_);
+//         return covariance;
+//       }
+// 
+//       /* Get the moments of the standardized distribution */
+//       Burr::NumericalPoint Burr::getStandardMoment(const UnsignedLong n) const
+//       {
+//         if (k_ == 0.0) return NumericalPoint(1, SpecFunc::K(n + 1));
+// 	const NumericalScalar expK(exp(k_));
+//         return NumericalPoint(1, expK * (SpecFunc::K(n + 1) - pow(k_, n + 1) * SpecFunc::HyperGeom_1_1(n + 1, n + 2, -k_) / (n + 1)));
+//       }
+// 
+      /* Parameters value and description accessor */
+      Burr::NumericalPointWithDescriptionCollection Burr::getParametersCollection() const
+      {
+        NumericalPointWithDescriptionCollection parameters(1);
+        NumericalPointWithDescription point(2);
+        Description description(point.getDimension());
+        point[0] = c_;
+        point[1] = k_;
+        description[0] = "c";
+        description[1] = "k";
+        point.setDescription(description);
+        point.setName(getDescription()[0]);
+        parameters[0] = point;
+        return parameters;
+      }
+
+      void Burr::setParametersCollection(const NumericalPointCollection & parametersCollection)
+      {
+        *this = Burr(parametersCollection[0][0], parametersCollection[0][1]);
+      }
+
+      /* C accessor */
+      void Burr::setC(const NumericalScalar c)
+        /* throw(InvalidArgumentException) */
+      {
+        if (c <= 0.) throw InvalidArgumentException(HERE) << "C MUST be positive";
+        c_ = c;
+        computeRange();
+      }
+
+      /* C accessor */
+      NumericalScalar Burr::getC() const
+      {
+        return c_;
+      }
+
+
+      /* K accessor */
+      void Burr::setK(const NumericalScalar k)
+      {
+        if (k <= 0.) throw InvalidArgumentException(HERE) << "K MUST be positive";
+        k_ = k;
+        computeRange();
+      }
+
+      /* K accessor */
+      NumericalScalar Burr::getK() const
+      {
+        return k_;
+      }
+
+      /* Method save() stores the object through the StorageManager */
+      void Burr::save(StorageManager::Advocate & adv) const
+      {
+        NonEllipticalDistribution::save(adv);
+        adv.saveAttribute( "c_", c_ );
+        adv.saveAttribute( "k_", k_ );
+      }
+
+      /* Method load() reloads the object from the StorageManager */
+      void Burr::load(StorageManager::Advocate & adv)
+      {
+        NonEllipticalDistribution::load(adv);
+        adv.loadAttribute( "c_", c_ );
+        adv.loadAttribute( "k_", k_ );
+        computeRange();
+      }
+
+
+
+
+    } /* namespace Distribution */
+  } /* namespace Uncertainty */
+} /* namespace OpenTURNS */

Modification de propriétés sur lib/src/Uncertainty/Distribution/Burr.cxx
___________________________________________________________________
Ajouté : svn:executable
   + *

Index: lib/src/Uncertainty/Distribution/Makefile.am
===================================================================
--- lib/src/Uncertainty/Distribution/Makefile.am	(révision 1842)
+++ lib/src/Uncertainty/Distribution/Makefile.am	(copie de travail)
@@ -60,6 +60,7 @@
 	TruncatedNormal.hxx \
 	Epanechnikov.hxx \
 	Exponential.hxx \
+	Burr.hxx \
 	ChiSquare.hxx \
 	Gamma.hxx \
 	LogNormal.hxx \
@@ -123,6 +124,7 @@
 	TruncatedNormal.cxx \
 	Epanechnikov.cxx \
 	Exponential.cxx \
+	Burr.cxx \
 	ChiSquare.cxx \
 	Gamma.cxx \
 	LogNormal.cxx \
