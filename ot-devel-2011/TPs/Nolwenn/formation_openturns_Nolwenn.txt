diff --git a/lib/src/Uncertainty/Distribution/CMakeLists.txt b/lib/src/Uncertainty/Distribution/CMakeLists.txt
index 15142fd..08a869e 100644
--- a/lib/src/Uncertainty/Distribution/CMakeLists.txt
+++ b/lib/src/Uncertainty/Distribution/CMakeLists.txt
@@ -96,6 +96,7 @@ ot_add_source_file ( KernelSmoothing.cxx )
 ot_add_source_file ( KernelMixture.cxx )
 ot_add_source_file ( Rayleigh.cxx )
 ot_add_source_file ( RayleighFactory.cxx )
+ot_add_source_file ( ZipfMandelbrot.cxx )
 
 ot_install_header_file ( ChiSquare.hxx )
 ot_install_header_file ( LogNormalFactory.hxx )
@@ -166,6 +167,7 @@ ot_install_header_file ( UserDefined.hxx )
 ot_install_header_file ( UserDefinedPair.hxx )
 ot_install_header_file ( ClaytonCopulaFactory.hxx )
 ot_install_header_file ( FrankCopula.hxx )
+ot_install_header_file ( ZipfMandelbrot.hxx )
 
 # Recurse in subdirectories
 add_subdirectory ( ExtraFunc )
diff --git a/lib/src/Uncertainty/Distribution/Makefile.am b/lib/src/Uncertainty/Distribution/Makefile.am
index 910e51a..0b89c79 100644
--- a/lib/src/Uncertainty/Distribution/Makefile.am
+++ b/lib/src/Uncertainty/Distribution/Makefile.am
@@ -120,6 +120,7 @@ otinclude_HEADERS = \
 	KernelSmoothing.hxx \
 	KernelMixture.hxx \
 	Rayleigh.hxx \
+	ZipfMandelbrot.hxx \
 	RayleighFactory.hxx
 
 noinst_LTLIBRARIES     = libOTDistribution.la
@@ -201,6 +202,7 @@ libOTDistribution_la_SOURCES = \
 	KernelSmoothing.cxx \
 	KernelMixture.cxx \
 	Rayleigh.cxx \
-	RayleighFactory.cxx
+	RayleighFactory.cxx \
+	ZipfMandelbrot.cxx
 
 EXTRA_DIST = CMakeLists.txt
diff --git a/lib/src/Uncertainty/Distribution/OTDistribution.hxx b/lib/src/Uncertainty/Distribution/OTDistribution.hxx
index 771e1b8..f454d2d 100644
--- a/lib/src/Uncertainty/Distribution/OTDistribution.hxx
+++ b/lib/src/Uncertainty/Distribution/OTDistribution.hxx
@@ -99,5 +99,6 @@
 #include "UserDefinedFactory.hxx"
 #include "Weibull.hxx"
 #include "WeibullFactory.hxx"
+#include "ZipfMandelbrot.hxx"
 
 #endif /* OPENTURNS_OTDISTRIBUTION_HXX */
diff --git a/lib/src/Uncertainty/Distribution/ZipfMandelbrot.cxx b/lib/src/Uncertainty/Distribution/ZipfMandelbrot.cxx
new file mode 100644
index 0000000..2e6f40d
--- /dev/null
+++ b/lib/src/Uncertainty/Distribution/ZipfMandelbrot.cxx
@@ -0,0 +1,281 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  ZipfMandelbrot.cxx
+ *  @brief The ZipfMandelbrot distribution
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy: dutka $
+ *  @date:   $LastChangedDate: 2010-07-12 15:45:44 +0200 (lun. 12 juil. 2010) $
+ *  Id:      $Id: ZipfMandelbrot.cxx 1581 2010-07-12 13:45:44Z dutka $
+ */
+#include <cmath>
+#include "ZipfMandelbrot.hxx"
+#include "DistFunc.hxx"
+#include "RandomGenerator.hxx"
+#include "PersistentObjectFactory.hxx"
+#include "Exception.hxx"
+
+namespace OpenTURNS {
+
+  namespace Uncertainty {
+
+    namespace Distribution {
+
+      typedef Base::Stat::RandomGenerator              RandomGenerator;
+      typedef Base::Common::NotYetImplementedException NotYetImplementedException;
+
+      CLASSNAMEINIT(ZipfMandelbrot);
+
+      static Base::Common::Factory<ZipfMandelbrot> RegisteredFactory("ZipfMandelbrot");
+
+      /* Default constructor */
+      ZipfMandelbrot::ZipfMandelbrot()
+        : DiscreteDistribution("ZipfMandelbrot"),
+          n_(1),
+          q_(0.),
+	  s_(1.),
+	  isAlreadyComputedHarmonicNumbers_(false),
+	  harmonicNumbers_(0)
+      {
+        // We set the dimension of the ZipfMandelbrot distribution
+        setDimension( 1 );
+        computeRange();
+
+      }
+
+      /* Parameters constructor */
+      ZipfMandelbrot::ZipfMandelbrot(const UnsignedLong n,
+				     const NumericalScalar q,
+				     const NumericalScalar s )
+        : DiscreteDistribution("ZipfMandelbrot"),
+          n_(n),
+          q_(q),
+	  s_(s),
+	  isAlreadyComputedHarmonicNumbers_(false),
+	  harmonicNumbers_(NumericalScalarCollection(0))
+      {
+        // We set the dimension of the ZipfMandelbrot distribution
+        setDimension( 1 );
+        computeRange();
+
+      }
+
+      /* Comparison operator */
+      Bool ZipfMandelbrot::operator ==(const ZipfMandelbrot & other) const
+      {
+        return (n_ == other.n_) && (q_ == other.q_) && (s_ == other.s_);
+	}
+
+      /* String converter */
+      String ZipfMandelbrot::__repr__() const
+      {
+        OSS oss;
+        oss << "class=" << ZipfMandelbrot::GetClassName()
+            << " name=" << getName()
+            << " dimension=" << getDimension()
+            << " n=" << n_
+            << " q=" << q_
+            << " s=" << s_;
+        return oss;
+	}
+
+      /* Virtual constructor */
+      ZipfMandelbrot * ZipfMandelbrot::clone() const
+      {
+        return new ZipfMandelbrot(*this);
+      }
+
+      /* Get one realization of the distribution */
+      ZipfMandelbrot::NumericalPoint ZipfMandelbrot::getRealization() const
+      {
+        const NumericalScalar uniformRealization(1-RandomGenerator::Generate());
+
+	if (isAlreadyComputedHarmonicNumbers_ == false) 
+	  	  computeHarmonicNumbers();
+
+	NumericalScalarCollection::iterator it =  
+	  lower_bound(harmonicNumbers_.begin(),
+		      harmonicNumbers_.end(), 
+		      uniformRealization * getHarmonicNumbers(n_));
+	
+	return NumericalPoint(1, it - harmonicNumbers_.begin() + 1);
+      }
+
+
+      /* Get the PDF of the distribution */
+      NumericalScalar ZipfMandelbrot::computePDF(const NumericalPoint & point) const
+      {
+        const NumericalScalar k(point[0]);
+
+        if ((k < 1 -DiscreteDistribution::SupportEpsilon) || (fabs(k - round(k)) > DiscreteDistribution::SupportEpsilon) || (k > n_ + DiscreteDistribution::SupportEpsilon)) return 0.0;
+
+	NumericalScalar hnqs(getHarmonicNumbers(n_));
+	NumericalScalar value(1./ ( pow(round(k)+q_,s_) *  hnqs ) );
+
+	return value;
+      }
+
+
+      /* Get the CDF of the distribution */
+      NumericalScalar ZipfMandelbrot::computeCDF(const NumericalPoint & point,
+						 const Bool tail) const
+      {
+        const NumericalScalar k(point[0]);
+
+        if (k < 1 -DiscreteDistribution::SupportEpsilon) return (tail ? 1.0 : 0.0);
+        if (k > n_ + DiscreteDistribution::SupportEpsilon) return (tail ? 0.0 : 1.0);
+
+	NumericalScalar value (getHarmonicNumbers(round(k)) / getHarmonicNumbers(n_));
+
+	if (tail) value = 1 - value;
+	return value;
+
+      }
+
+      /* Q accessor */
+      NumericalScalar ZipfMandelbrot::getQ() const
+      {
+        return q_;
+      }
+
+      void ZipfMandelbrot::setQ(const NumericalScalar q)
+      /* throw(InvalidArgumentException) */
+      {
+        if (q < 0) throw InvalidArgumentException(HERE) << "q must be >= 0";
+        q_ = q;
+        computeRange();
+      }
+
+      /* S accessor */
+      NumericalScalar ZipfMandelbrot::getS() const
+      {
+        return s_;
+      }
+
+      void ZipfMandelbrot::setS(const NumericalScalar s)
+      /* throw(InvalidArgumentException) */
+      {
+        if (s <= 0) throw InvalidArgumentException(HERE) << "s must be > 0";
+        s_ = s;
+        computeRange();
+      }
+
+      /* N accessor */
+      UnsignedLong ZipfMandelbrot::getN() const
+      {
+        return n_;
+      }
+
+      void ZipfMandelbrot::setN(const UnsignedLong n)
+      /* throw(InvalidArgumentException) */
+      {
+        if (n == 0) throw InvalidArgumentException(HERE) << "N must be > 0";
+        n_ = n;
+        computeRange();
+      }
+
+
+      /* Compute the numerical range of the distribution given the parameters values */
+      void ZipfMandelbrot::computeRange()
+      {
+	const NumericalPoint lowerBound(1, 1.0);
+        const NumericalPoint upperBound(1, n_);
+        const Interval::BoolCollection finiteLowerBound(1, true);
+        const Interval::BoolCollection finiteUpperBound(1, true);
+        setRange(Interval(lowerBound, upperBound, finiteLowerBound, finiteUpperBound));
+      }
+
+      /* Get the support of a discrete distribution that intersect a given interval */
+      ZipfMandelbrot::NumericalSample ZipfMandelbrot::getSupport(const Interval & interval) const
+      {
+        if (interval.getDimension() != getDimension()) throw InvalidArgumentException(HERE) << "Error: the given interval has a dimension that does not match the distribution dimension.";
+        const UnsignedLong kMin(static_cast< UnsignedLong > (std::max(ceil(interval.getLowerBound()[0]), 1.0)));
+        const UnsignedLong kMax(static_cast< UnsignedLong > (std::min(floor(interval.getUpperBound()[0]), NumericalScalar(n_))));
+        NumericalSample result(0, 1);
+        for (UnsignedLong k = kMin; k <= kMax; ++k) result.add(NumericalPoint(1, k));
+        return result;
+      }
+
+      /* Tell if the distribution is integer valued */
+      Bool ZipfMandelbrot::isIntegral() const
+      {
+	return true;
+      }
+
+
+
+      /* Method save() stores the object through the StorageManager */
+      void ZipfMandelbrot::save(StorageManager::Advocate & adv) const
+      {
+        DiscreteDistribution::save(adv);
+        adv.saveAttribute( "n_", n_ );
+        adv.saveAttribute( "q_", q_ );
+        adv.saveAttribute( "s_", s_ );
+      }
+
+      /* Method load() reloads the object from the StorageManager */
+      void ZipfMandelbrot::load(StorageManager::Advocate & adv)
+      {
+        DiscreteDistribution::load(adv);
+        adv.loadAttribute( "n_", n_ );
+        adv.loadAttribute( "q_", q_ );
+        adv.loadAttribute( "s_", s_ );
+	isAlreadyComputedHarmonicNumbers_ = false;
+	harmonicNumbers_ = NumericalScalarCollection(0);
+        computeRange();
+      }
+
+
+      /* Method getHarmonicNumbers returns the k-th harmonic number for the current distribution */
+      NumericalScalar ZipfMandelbrot::getHarmonicNumbers(UnsignedLong const k ) const
+      {
+	if (isAlreadyComputedHarmonicNumbers_ == false) 
+	  computeHarmonicNumbers();
+	
+	if (k<1)  throw InvalidArgumentException(HERE) << "k must be >= 1" ;
+	if (k>n_)  throw InvalidArgumentException(HERE) << "k must be <= N";
+
+	return harmonicNumbers_[k-1];
+
+      }
+
+      /* Method  computeHarmonicNumbers computes and stores the  of the k harmonic numbers for 
+	 k=1..n 
+	 harmonicNumbers_[i] = _{l=1}^i 1./( (i+q)**s )
+      */
+      void ZipfMandelbrot::computeHarmonicNumbers() const
+      {
+	if (isAlreadyComputedHarmonicNumbers_ == false) 
+	  {
+	    harmonicNumbers_ = NumericalScalarCollection(n_);
+
+	    harmonicNumbers_[0] =  (1./ ( pow(1+q_,s_)));
+	    for (UnsignedLong i = 2; i<=n_; ++i)
+	      {
+		NumericalScalar hiqs (1./ ( pow(i+q_,s_)));
+		harmonicNumbers_[i-1] = harmonicNumbers_[i-2] + hiqs;
+	      }
+
+	    isAlreadyComputedHarmonicNumbers_ = true;
+	  }
+      }
+
+
+    } /* namespace Distribution */
+  } /* namespace Uncertainty */
+} /* namespace OpenTURNS */
diff --git a/lib/src/Uncertainty/Distribution/ZipfMandelbrot.hxx b/lib/src/Uncertainty/Distribution/ZipfMandelbrot.hxx
new file mode 100644
index 0000000..cacdb57
--- /dev/null
+++ b/lib/src/Uncertainty/Distribution/ZipfMandelbrot.hxx
@@ -0,0 +1,150 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  ZipfMandelbrot.hxx
+ *  @brief The ZipfMandelbrot distribution
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy: dutka $
+ *  @date:   $LastChangedDate: 2010-07-12 15:45:44 +0200 (lun. 12 juil. 2010) $
+ *  Id:      $Id: ZipfMandelbrot.hxx 1581 2010-07-12 13:45:44Z dutka $
+ */
+#ifndef OPENTURNS_ZIPFMANDELBROT_HXX
+#define OPENTURNS_ZIPFMANDELBROT_HXX
+
+#include "OTprivate.hxx"
+#include "DiscreteDistribution.hxx"
+#include "Exception.hxx"
+
+namespace OpenTURNS {
+
+  namespace Uncertainty {
+
+    namespace Distribution {
+
+
+      /**
+       * @class ZipfMandelbrot
+       *
+       * The ZipfMandelbrot distribution.
+       */
+      class ZipfMandelbrot
+        : public Model::DiscreteDistribution
+      {
+        CLASSNAME;
+      public:
+
+        typedef Base::Common::InvalidArgumentException               InvalidArgumentException;
+        typedef Model::DiscreteDistribution                          DiscreteDistribution;  // required by SWIG
+        typedef DiscreteDistribution::NumericalPoint                 NumericalPoint;
+        typedef DiscreteDistribution::NumericalSample                NumericalSample;
+        typedef DiscreteDistribution::CovarianceMatrix               CovarianceMatrix;
+        typedef DiscreteDistribution::NumericalPointWithDescriptionCollection       NumericalPointWithDescriptionCollection;
+        typedef DiscreteDistribution::NotDefinedException            NotDefinedException;
+        typedef DiscreteDistribution::StorageManager                 StorageManager;
+	typedef Base::Type::Collection<NumericalScalar>              NumericalScalarCollection;
+
+
+        /** Default constructor */
+        ZipfMandelbrot();
+
+        /** Parameters constructor */
+        ZipfMandelbrot(const UnsignedLong n,
+		       const NumericalScalar q,
+		       const NumericalScalar s);
+	
+        /** Comparison operator */
+        Bool operator ==(const ZipfMandelbrot & other) const;
+
+        /** String converter */
+        String __repr__() const;
+
+
+
+        /* Interface inherited from Distribution */
+
+        /** Virtual constructor */
+        virtual ZipfMandelbrot * clone() const;
+
+	/** Get one realization of the distribution */
+	NumericalPoint getRealization() const;
+
+        /** Get the PDF of the distribution */
+        using DiscreteDistribution::computePDF;
+	  NumericalScalar computePDF(const NumericalPoint & point) const;
+
+        /** Get the CDF of the distribution */
+        using DiscreteDistribution::computeCDF;
+        NumericalScalar computeCDF(const NumericalPoint & point, const Bool tail = false) const;
+
+        /* Interface specific to ZipfMandelbrot */
+
+        /** Q accessor */
+        void setQ(const NumericalScalar q);
+        NumericalScalar getQ() const;
+
+        /** S accessor */
+        void setS(const NumericalScalar s);
+        NumericalScalar getS() const;
+ 
+	/** N accessor */
+        void setN(const UnsignedLong n);
+        UnsignedLong getN() const;
+
+        /** Get the support of a discrete distribution that intersect a given interval */
+        NumericalSample getSupport(const Interval & interval) const;
+
+	/** Tell if the distribution is integer valued */
+	Bool isIntegral() const;
+
+        /** Method save() stores the object through the StorageManager */
+        void save(StorageManager::Advocate & adv) const;
+
+        /** Method load() reloads the object from the StorageManager */
+        void load(StorageManager::Advocate & adv);
+
+      protected:
+
+	NumericalScalar getHarmonicNumbers(UnsignedLong const) const;
+	void computeHarmonicNumbers() const;
+
+	mutable Bool isAlreadyComputedHarmonicNumbers_;
+	mutable NumericalScalarCollection harmonicNumbers_;
+	
+
+      private:
+
+        /** Compute the numerical range of the distribution given the parameters values */
+        void computeRange();
+
+        /** The maximum value of the ZipfMandelbrot distribution */
+        UnsignedLong n_;
+
+        /** The q probability parameter of the ZipfMandelbrot distribution */
+        NumericalScalar q_;
+
+        /** The s probability parameter of the ZipfMandelbrot distribution */
+        NumericalScalar s_;
+
+      }; /* class ZipfMandelbrot */
+
+
+    } /* namespace Distribution */
+  } /* namespace Uncertainty */
+} /* namespace OpenTURNS */
+
+#endif /* OPENTURNS_ZIPFMANDELBROT_HXX */
diff --git a/lib/test/CMakeLists.txt b/lib/test/CMakeLists.txt
index 671a0b8..f4c882e 100644
--- a/lib/test/CMakeLists.txt
+++ b/lib/test/CMakeLists.txt
@@ -321,6 +321,7 @@ ot_check_test ( DistFunc_normal )
 ot_check_test ( DistFunc_poisson )
 ot_check_test ( DistFunc_student )
 ot_check_test ( Distributions_draw )
+ot_check_test ( ZipfMandelbrot )
 
 # Model
 ot_check_test ( RandomVector_constant )
diff --git a/lib/test/Makefile.am b/lib/test/Makefile.am
index 5ccb500..a1bce26 100644
--- a/lib/test/Makefile.am
+++ b/lib/test/Makefile.am
@@ -260,6 +260,7 @@ CHECK_TESTS += $(srcdir)/t_DistFunc_normal.at
 CHECK_TESTS += $(srcdir)/t_DistFunc_poisson.at
 CHECK_TESTS += $(srcdir)/t_DistFunc_student.at
 CHECK_TESTS += $(srcdir)/t_Distributions_draw.at
+CHECK_TESTS += $(srcdir)/t_ZipfMandelbrot_std.at
 
 ## Model
 CHECK_TESTS += $(srcdir)/t_RandomVector_constant.at
@@ -516,6 +517,7 @@ OUTFILES += $(srcdir)/t_DistFunc_normal.expout
 OUTFILES += $(srcdir)/t_DistFunc_poisson.expout
 OUTFILES += $(srcdir)/t_DistFunc_student.expout
 OUTFILES += $(srcdir)/t_Distributions_draw.expout
+OUTFILES += $(srcdir)/t_ZipfMandelbrot_std.expout
 
 ## Model
 OUTFILES += $(srcdir)/t_RandomVector_constant.expout
@@ -778,6 +780,7 @@ CHECK_PROGS += t_DistFunc_normal
 CHECK_PROGS += t_DistFunc_poisson
 CHECK_PROGS += t_DistFunc_student
 CHECK_PROGS += t_Distributions_draw
+CHECK_PROGS += t_ZipfMandelbrot_std
 
 ## IsoProbabilisticTransformation
 CHECK_PROGS += t_MarginalTransformationEvaluation_std
@@ -1750,6 +1753,7 @@ t_DistFunc_noncentralstudent_SOURCES                               = t_DistFunc_
 t_DistFunc_normal_SOURCES                                          = t_DistFunc_normal.cxx
 t_DistFunc_poisson_SOURCES                                         = t_DistFunc_poisson.cxx
 t_DistFunc_student_SOURCES                                         = t_DistFunc_student.cxx
+t_ZipfMandelbrot_std_SOURCES                                       = t_ZipfMandelbrot_std.cxx
 
 examplesSources += $(t_Beta_std_SOURCES)
 examplesSources += $(t_BetaFactory_std_SOURCES)
diff --git a/lib/test/check_testsuite.at b/lib/test/check_testsuite.at
index 7261c7c..c546d11 100644
--- a/lib/test/check_testsuite.at
+++ b/lib/test/check_testsuite.at
@@ -208,6 +208,7 @@ m4_include(t_DistFunc_normal.at)
 m4_include(t_DistFunc_poisson.at)
 m4_include(t_DistFunc_student.at)
 m4_include(t_Distributions_draw.at)
+m4_include(t_ZipfMandelbrot_std.at)
 
 # Model
 m4_include(t_RandomVector_constant.at)
diff --git a/lib/test/t_ZipfMandelbrot_std.at b/lib/test/t_ZipfMandelbrot_std.at
new file mode 100644
index 0000000..6af3fcf
--- /dev/null
+++ b/lib/test/t_ZipfMandelbrot_std.at
@@ -0,0 +1,14 @@
+AT_SETUP([ZipfMandelbrot])
+
+AT_KEYWORDS([std Uncertainty Distribution ZipfMandelbrot])
+
+#AT_TESTED([t_ZipfMandelbrot_std])
+
+AT_CHECK([cp $abs_srcdir/t_ZipfMandelbrot_std.expout expout],[0],[ignore],[ignore])
+
+AT_CHECK([t_ZipfMandelbrot_std],
+         [0],
+         [expout],
+         [ignore])
+
+AT_CLEANUP
diff --git a/lib/test/t_ZipfMandelbrot_std.cxx b/lib/test/t_ZipfMandelbrot_std.cxx
new file mode 100644
index 0000000..693bae0
--- /dev/null
+++ b/lib/test/t_ZipfMandelbrot_std.cxx
@@ -0,0 +1,131 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  t_ZipfMandelbrot_std.cxx
+ *  @brief The test file of class ZipfMandelbrot for standard methods
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy: dutka $
+ *  @date:   $LastChangedDate: 2010-02-04 16:44:49 +0100 (jeu. 04 févr. 2010) $
+ *  Id:      $Id: t_ZipfMandelbrot_std.cxx 1473 2010-02-04 15:44:49Z dutka $
+ */
+#include <iostream>
+#include <sstream>
+#include "OT.hxx"
+#include "OTtestcode.hxx"
+#include "OStream.hxx"
+#include "OTGraph.hxx"
+#include "ZipfMandelbrot.hxx"
+#include "NumericalPoint.hxx"
+#include "NumericalSample.hxx"
+
+using namespace OT;
+using namespace OT::Test;
+using namespace OT::Base::Common;
+using namespace OT::Base::Common;
+using namespace OT::Base::Type;
+using namespace OT::Base::Stat;
+using namespace OT::Uncertainty::Distribution;
+using namespace OT::Base::Graph;
+
+
+class TestObject : public ZipfMandelbrot
+{
+public:
+  explicit TestObject() : ZipfMandelbrot(15, 1.2, 2.) {}
+  explicit TestObject(const String & name) : ZipfMandelbrot(15, 1.2, 2.) {setName(name);}
+  virtual ~TestObject() {}
+};
+
+
+int main(int argc, char *argv[])
+{
+  TESTPREAMBLE;
+  OStream fullprint(std::cout);
+  setRandomGenerator();
+
+  try {
+    // Test basic functionnalities
+    checkClassWithClassName<TestObject>();
+
+    // Test some extra functionnalities
+    checkNameFeature<TestObject>();
+
+    // Instanciate one distribution object
+    ZipfMandelbrot distribution(15, 1.2, 2.);
+    fullprint << "Distribution " << distribution << std::endl;
+
+    // Is this distribution elliptical ?
+    fullprint << "Elliptical = " << (distribution.isElliptical() ? "true" : "false") << std::endl;
+
+    // Is this distribution continuous ?
+    fullprint << "Continuous = " << (distribution.isContinuous() ? "true" : "false") << std::endl;
+
+    // Test for realization of distribution
+    NumericalPoint oneRealization = distribution.getRealization();
+    fullprint << "oneRealization=" << oneRealization << std::endl;
+
+    // Test 
+    fullprint << "getRange=" << distribution.getRange() << std::endl;
+
+    // Test
+    Graph graphCDF(distribution.drawCDF(0., 16., 17.));
+    graphCDF.draw("testDrawCDF");
+
+
+    // Test for sampling
+    UnsignedLong size = 1000;
+    NumericalSample oneSample = distribution.getNumericalSample( size );
+    fullprint << "oneSample first=" << oneSample[0] << " last=" << oneSample[size - 1] << std::endl;
+    fullprint << "mean=" << oneSample.computeMean() << std::endl;
+    fullprint << "covariance=" << oneSample.computeCovariance() << std::endl;
+
+    // Define a point
+    NumericalPoint point( distribution.getDimension(), 5.0 );
+    fullprint << "Point= " << point << std::endl;
+
+    // Show PDF and CDF of point
+    NumericalScalar eps(1e-5);
+    NumericalScalar PDF = distribution.computePDF( point );
+    fullprint << "pdf     =" << PDF << std::endl;
+    fullprint << "pdf (FD)=" << (distribution.computeCDF( point + NumericalPoint(1, 0) ) - distribution.computeCDF( point  + NumericalPoint(1, -1) )) << std::endl;
+    NumericalScalar CDF = distribution.computeCDF( point );
+    fullprint << "cdf=" << CDF << std::endl;
+    NumericalPoint quantile = distribution.computeQuantile( 0.95 );
+    fullprint << "quantile=" << quantile << std::endl;
+    fullprint << "cdf(quantile)=" << distribution.computeCDF(quantile) << std::endl;
+    NumericalPoint mean = distribution.getMean();
+    fullprint << "mean=" << mean << std::endl;
+    NumericalPoint standardDeviation = distribution.getStandardDeviation();
+    fullprint << "standard deviation=" << standardDeviation << std::endl;
+    NumericalPoint skewness = distribution.getSkewness();
+    fullprint << "skewness=" << skewness << std::endl;
+    NumericalPoint kurtosis = distribution.getKurtosis();
+    fullprint << "kurtosis=" << kurtosis << std::endl;
+    CovarianceMatrix covariance = distribution.getCovariance();
+    fullprint << "covariance=" << covariance << std::endl;
+    ZipfMandelbrot::NumericalPointWithDescriptionCollection parameters = distribution.getParametersCollection();
+    fullprint << "parameters=" << parameters << std::endl;
+  }
+  catch (TestFailed & ex) {
+    std::cerr << ex << std::endl;
+    return ExitCode::Error;
+  }
+
+
+  return ExitCode::Success;
+}
diff --git a/lib/test/t_ZipfMandelbrot_std.expout b/lib/test/t_ZipfMandelbrot_std.expout
new file mode 100644
index 0000000..449da01
--- /dev/null
+++ b/lib/test/t_ZipfMandelbrot_std.expout
@@ -0,0 +1,36 @@
+Testing class ZipfMandelbrot
+checkConstructorAndDestructor()
+checkCopyConstructor()
+streamObject(const T & anObject)
+class=ZipfMandelbrot name=ZipfMandelbrot dimension=1 n=15 q=1.2 s=2
+streamObject(const T & anObject)
+class=ZipfMandelbrot name=ZipfMandelbrot dimension=1 n=15 q=1.2 s=2
+areSameObjects(const T & firstObject, const T & secondObject)
+areDifferentObjects(const T & firstObject, const T & secondObject)
+checkNameFeature()
+checkNameConstructor()
+streamObject(const T & anObject)
+class=ZipfMandelbrot name=myName dimension=1 n=15 q=1.2 s=2
+checkNameAccessors()
+streamObject(const T & anObject)
+class=ZipfMandelbrot name=myNewName dimension=1 n=15 q=1.2 s=2
+Distribution class=ZipfMandelbrot name=ZipfMandelbrot dimension=1 n=15 q=1.2 s=2
+Elliptical = false
+Continuous = false
+oneRealization=class=NumericalPoint name=Unnamed dimension=1 values=[1]
+getRange=class=Interval name=Unnamed dimension=1 lower bound=class=NumericalPoint name=Unnamed dimension=1 values=[1] upper bound=class=NumericalPoint name=Unnamed dimension=1 values=[15] finite lower bound=[1] finite upper bound=[1]
+oneSample first=class=NumericalPoint name=Unnamed dimension=1 values=[1] last=class=NumericalPoint name=Unnamed dimension=1 values=[1]
+mean=class=NumericalPoint name=Unnamed dimension=1 values=[3.256]
+covariance=class=CovarianceMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[10.2227]
+Point= class=NumericalPoint name=Unnamed dimension=1 values=[5]
+pdf     =0.0507037
+pdf (FD)=0.0507037
+cdf=0.826308
+quantile=class=NumericalPoint name=Unnamed dimension=1 values=[9.5]
+cdf(quantile)=0.934653
+mean=class=NumericalPoint name=Unnamed dimension=1 values=[2.92818]
+standard deviation=class=NumericalPoint name=Unnamed dimension=1 values=[2.96692]
+skewness=class=NumericalPoint name=Unnamed dimension=1 values=[1.96253]
+kurtosis=class=NumericalPoint name=Unnamed dimension=1 values=[6.36579]
+covariance=class=CovarianceMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[8.80259]
+parameters=[class=NumericalPointWithDescription name=Unnamed dimension=0 description=[] values=[]]
diff --git a/python/src/CMakeLists.txt b/python/src/CMakeLists.txt
index a7fcc35..33c332b 100644
--- a/python/src/CMakeLists.txt
+++ b/python/src/CMakeLists.txt
@@ -323,6 +323,7 @@ ot_add_python_module ( model_dist model_dist.i
 				  UserDefinedFactory.i
 				  Weibull.i
 				  WeibullFactory.i
+				  ZipfMandelbrot.i	
 				  IndependentCopula.i
 				  NormalCopula.i
 				  NormalCopulaFactory.i
diff --git a/python/src/Makefile.am b/python/src/Makefile.am
index 49a71d3..31643db 100644
--- a/python/src/Makefile.am
+++ b/python/src/Makefile.am
@@ -688,6 +688,7 @@ OPENTURNS_MODEL_DIST_SWIG_SRC = \
 	UserDefinedFactory.i \
 	Weibull.i \
 	WeibullFactory.i \
+	ZipfMandelbrot.i \
 	IndependentCopula.i \
 	NormalCopula.i \
 	NormalCopulaFactory.i \
diff --git a/python/src/ZipfMandelbrot.i b/python/src/ZipfMandelbrot.i
new file mode 100644
index 0000000..b1925db
--- /dev/null
+++ b/python/src/ZipfMandelbrot.i
@@ -0,0 +1,11 @@
+// SWIG file ZipfMandelbrot.i
+// Author : $LastChangedBy: dutka $
+// Date : $LastChangedDate: 2007-03-07 15:50:39 +0100 (mer. 07 mars 2007) $
+// Id : $Id: ZipfMandelbrot.i 345 2007-03-07 14:50:39Z dutka $
+
+%{
+#include "ZipfMandelbrot.hxx"
+%}
+
+%include ZipfMandelbrot.hxx
+namespace OpenTURNS { namespace Uncertainty { namespace Distribution { %extend ZipfMandelbrot { ZipfMandelbrot(const ZipfMandelbrot & other) { return new OpenTURNS::Uncertainty::Distribution::ZipfMandelbrot(other); } } }}}
diff --git a/python/src/model_dist.i b/python/src/model_dist.i
index 3b91ead..6331e2c 100644
--- a/python/src/model_dist.i
+++ b/python/src/model_dist.i
@@ -99,6 +99,7 @@
 %include UserDefinedFactory.i
 %include Weibull.i
 %include WeibullFactory.i
+%include ZipfMandelbrot.i
 %include IndependentCopula.i
 %include NormalCopula.i
 %include NormalCopulaFactory.i
diff --git a/python/test/CMakeLists.txt b/python/test/CMakeLists.txt
index dd0fec4..c04c541 100644
--- a/python/test/CMakeLists.txt
+++ b/python/test/CMakeLists.txt
@@ -285,6 +285,7 @@ ot_pyinstallcheck_test ( UserDefined_std )
 ot_pyinstallcheck_test ( UserDefinedFactory_std )
 ot_pyinstallcheck_test ( Weibull_std )
 ot_pyinstallcheck_test ( WeibullFactory_std )
+ot_pyinstallcheck_test ( ZipfMandelbrot_std )
 ot_pyinstallcheck_test ( Mixture_std )
 ot_pyinstallcheck_test ( DistFunc_beta )
 ot_pyinstallcheck_test ( DistFunc_gamma )
diff --git a/python/test/Makefile.am b/python/test/Makefile.am
index 0a26ae6..5d431a3 100644
--- a/python/test/Makefile.am
+++ b/python/test/Makefile.am
@@ -256,6 +256,7 @@ PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_UserDefined_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_UserDefinedFactory_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_Weibull_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_WeibullFactory_std.atpy
+PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_ZipfMandelbrot_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_Mixture_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_DistFunc_beta.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_DistFunc_gamma.atpy
@@ -563,6 +564,7 @@ OUTFILES += $(srcdir)/t_UserDefined_std.expout
 OUTFILES += $(srcdir)/t_UserDefinedFactory_std.expout
 OUTFILES += $(srcdir)/t_Weibull_std.expout
 OUTFILES += $(srcdir)/t_WeibullFactory_std.expout
+OUTFILES += $(srcdir)/t_ZipfMandelbrot_std.expout
 OUTFILES += $(srcdir)/t_Mixture_std.expout
 OUTFILES += $(srcdir)/t_DistFunc_beta.expout
 OUTFILES += $(srcdir)/t_DistFunc_gamma.expout
@@ -867,6 +869,7 @@ PYTHONINSTALLCHECK_PROGS += t_UserDefined_std.py
 PYTHONINSTALLCHECK_PROGS += t_UserDefinedFactory_std.py
 PYTHONINSTALLCHECK_PROGS += t_Weibull_std.py
 PYTHONINSTALLCHECK_PROGS += t_WeibullFactory_std.py
+PYTHONINSTALLCHECK_PROGS += t_ZipfMandelbrot_std.py
 PYTHONINSTALLCHECK_PROGS += t_Mixture_std.py
 PYTHONINSTALLCHECK_PROGS += t_KernelMixture_std.py
 PYTHONINSTALLCHECK_PROGS += t_KernelSmoothing_std.py
diff --git a/python/test/python_installcheck_testsuite.at b/python/test/python_installcheck_testsuite.at
index 058641f..a1570e7 100644
--- a/python/test/python_installcheck_testsuite.at
+++ b/python/test/python_installcheck_testsuite.at
@@ -235,6 +235,7 @@ m4_include(t_UserDefined_std.atpy)
 m4_include(t_UserDefinedFactory_std.atpy)
 m4_include(t_Weibull_std.atpy)
 m4_include(t_WeibullFactory_std.atpy)
+m4_include(t_ZipfMandelbrot_std.atpy)
 m4_include(t_Mixture_std.atpy)
 m4_include(t_DistFunc_beta.atpy)
 m4_include(t_DistFunc_gamma.atpy)
diff --git a/python/test/t_ZipfMandelbrot_std.atpy b/python/test/t_ZipfMandelbrot_std.atpy
new file mode 100644
index 0000000..f77a4ff
--- /dev/null
+++ b/python/test/t_ZipfMandelbrot_std.atpy
@@ -0,0 +1,14 @@
+AT_SETUP([ZipfMandelbrot])
+
+AT_KEYWORDS([std Uncertainty Distribution ZipfMandelbrot])
+
+#AT_TESTED([t_ZipfMandelbrot_std.py])
+
+AT_CHECK([cp $abs_srcdir/t_ZipfMandelbrot_std.expout expout],[0],[ignore],[ignore])
+
+AT_CHECK([python ${examplesdir}/t_ZipfMandelbrot_std.py],
+         [0],
+         [expout],
+         [ignore])
+
+AT_CLEANUP
diff --git a/python/test/t_ZipfMandelbrot_std.expout b/python/test/t_ZipfMandelbrot_std.expout
new file mode 100644
index 0000000..fd2d96d
--- /dev/null
+++ b/python/test/t_ZipfMandelbrot_std.expout
@@ -0,0 +1,20 @@
+Distribution  class=ZipfMandelbrot name=ZipfMandelbrot dimension=1 n=15 q=1.2 s=2
+Elliptical =  False
+Continuous =  False
+oneRealization= class=NumericalPoint name=Unnamed dimension=1 values=[1]
+getRange= class=Interval name=Unnamed dimension=1 lower bound=class=NumericalPoint name=Unnamed dimension=1 values=[1] upper bound=class=NumericalPoint name=Unnamed dimension=1 values=[15] finite lower bound=[1] finite upper bound=[1]
+oneSample first= class=NumericalPoint name=Unnamed dimension=1 values=[1]  last= class=NumericalPoint name=Unnamed dimension=1 values=[7]
+mean= class=NumericalPoint name=Unnamed dimension=1 values=[3.256]
+covariance= class=CovarianceMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[10.2227]
+Point=  class=NumericalPoint name=Unnamed dimension=1 values=[5]
+pdf     =0.050704
+pdf (FD)=0.050704
+cdf=0.826308
+quantile= class=NumericalPoint name=Unnamed dimension=1 values=[9.5]
+cdf(quantile)=0.934653
+mean= class=NumericalPoint name=Unnamed dimension=1 values=[2.92818]
+standard deviation= class=NumericalPoint name=Unnamed dimension=1 values=[2.96692]
+skewness= class=NumericalPoint name=Unnamed dimension=1 values=[1.96253]
+kurtosis= class=NumericalPoint name=Unnamed dimension=1 values=[6.36579]
+covariance= class=CovarianceMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[8.80259]
+parameters= [class=NumericalPointWithDescription name=Unnamed dimension=0 description=[] values=[]]
diff --git a/python/test/t_ZipfMandelbrot_std.py b/python/test/t_ZipfMandelbrot_std.py
new file mode 100755
index 0000000..4a2afb3
--- /dev/null
+++ b/python/test/t_ZipfMandelbrot_std.py
@@ -0,0 +1,68 @@
+#! /usr/bin/env python
+
+from openturns import *
+
+TESTPREAMBLE()
+RandomGenerator().SetSeed(0)
+
+try :
+    # Instanciate one distribution object
+    distribution = ZipfMandelbrot(15, 1.2, 2.)
+    print "Distribution " , distribution
+
+    # Is this distribution elliptical ?
+    print "Elliptical = ", distribution.isElliptical()
+
+    # Is this distribution continuous ?
+    print "Continuous = ", distribution.isContinuous()
+
+    # Test for realization of distribution
+    oneRealization = distribution.getRealization()
+    print "oneRealization=", repr(oneRealization)
+
+    # Test for getRange
+    print "getRange=",repr(distribution.getRange())
+
+    # Test for sampling
+    size = 1000
+    oneSample = distribution.getNumericalSample( size )
+    print "oneSample first=" , repr(oneSample[0]) , " last=" , repr(oneSample[1])
+    print "mean=" , repr(oneSample.computeMean())
+    print "covariance=" , repr(oneSample.computeCovariance())
+
+    # Define a point
+    point = NumericalPoint( distribution.getDimension(), 5.0)
+    print "Point= " , repr(point)
+
+    # Show PDF and CDF of point
+    eps = 1e-5
+    # PDF value
+    PDF = distribution.computePDF( point )
+    print  "pdf     =%.6f" % PDF
+    # by the finite difference technique from CDF
+    print  "pdf (FD)=%.6f" % (distribution.computeCDF( point + NumericalPoint(1, 0) ) - distribution.computeCDF( point  + NumericalPoint(1, -1) ))
+
+    # derivative of the PDF with regards the parameters of the distribution
+    CDF = distribution.computeCDF( point )
+    print  "cdf=%.6f" % CDF
+    # quantile
+    quantile = distribution.computeQuantile( 0.95 )
+    print  "quantile=" , repr(quantile)
+    print  "cdf(quantile)=%.6f" % distribution.computeCDF(quantile)
+    mean = distribution.getMean()
+    print  "mean=" , repr(mean)
+    standardDeviation = distribution.getStandardDeviation()
+    print "standard deviation=" , repr(standardDeviation)
+    skewness = distribution.getSkewness()
+    print "skewness=" , repr(skewness)
+    kurtosis = distribution.getKurtosis()
+    print "kurtosis=" , repr(kurtosis)
+    covariance = distribution.getCovariance()
+    print  "covariance=" , repr(covariance)
+    parameters = distribution.getParametersCollection()
+    print  "parameters=" , repr(parameters)
+
+except :
+    import sys
+    print "t_Binomial.py", sys.exc_type, sys.exc_value
+    
