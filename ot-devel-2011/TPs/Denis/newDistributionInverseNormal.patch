commit 50980a670dd0dff51d8e3a17b076c726b7c1d152
Author: Denis Barbier <barbier@imacs.polytechnique.fr>
Date:   Wed Mar 23 20:13:17 2011 +0100

    New distribution: InverseNormal

diff --git a/lib/src/Uncertainty/Distribution/InverseNormal.cxx b/lib/src/Uncertainty/Distribution/InverseNormal.cxx
new file mode 100644
index 0000000..752839a
--- /dev/null
+++ b/lib/src/Uncertainty/Distribution/InverseNormal.cxx
@@ -0,0 +1,187 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  InverseNormal.cxx
+ *  @brief The InverseNormal distribution
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy$
+ *  @date:   $LastChangedDate$
+ *  Id:      $Id$
+ */
+#include <cmath>
+#include "InverseNormal.hxx"
+#include "DistFunc.hxx"
+#include "RandomGenerator.hxx"
+
+namespace OpenTURNS {
+
+  namespace Uncertainty {
+
+    namespace Distribution {
+
+      CLASSNAMEINIT(InverseNormal);
+
+      typedef Base::Stat::RandomGenerator RandomGenerator;
+
+      /* Default constructor */
+      InverseNormal::InverseNormal()
+        : NonEllipticalDistribution("InverseNormal"),
+          lambda_(1.0), mu_(1.0)
+      {
+        setDimension( 1 );
+        computeRange();
+      }
+
+      /* Parameters constructor */
+      InverseNormal::InverseNormal(const NumericalScalar lambda,
+                                   const NumericalScalar mu)
+        /* throw (InvalidArgumentException) */
+        : NonEllipticalDistribution("InverseNormal"),
+          lambda_(0.), mu_(0.)
+      {
+        // This call set also the range
+        setLambdaMu(lambda, mu);
+        setDimension( 1 );
+      }
+
+      /* Comparison operator */
+      Bool InverseNormal::operator ==(const InverseNormal & other) const {
+        Bool sameObject = false;
+
+        if (this != &other) { // Other is NOT me, so I have to realize the comparison
+          // sameObject = ...
+          // TODO: Write InverseNormal::operator ==(...)
+          sameObject = (lambda_ == other.lambda_) && (mu_ == other.mu_);
+        } else sameObject = true;
+
+        return sameObject;
+      }
+
+      /* String converter */
+      String InverseNormal::__repr__() const {
+        OSS oss;
+        oss << "class=" << InverseNormal::GetClassName()
+            << " name=" << getName()
+            << " dimension=" << getDimension()
+            << " lambda=" << lambda_
+            << " mu=" << mu_;
+        return oss;
+      }
+
+      /* Virtual constructor */
+      InverseNormal * InverseNormal::clone() const
+      {
+        return new InverseNormal(*this);
+      }
+
+      /* Get one realization of the distribution */
+      InverseNormal::NumericalPoint InverseNormal::getRealization() const
+      {
+        const NumericalScalar nu(DistFunc::rNormal());
+        const NumericalScalar y(nu * nu);
+        const NumericalScalar x(mu_ * (1.0 + (1.0 / (2.0 * lambda_)) * (mu_ * y - sqrt(4.0 * mu_ * lambda_ * y + mu_ * mu_ * y * y))));
+        const NumericalScalar z(RandomGenerator::Generate());
+        if (z * (mu_ + x) <= mu_) return NumericalPoint(1, x);
+        return NumericalPoint(1, mu_ * mu_ / x);
+      }
+
+
+      /* Get the PDF of the distribution */
+      NumericalScalar InverseNormal::computePDF(const NumericalPoint & point) const
+      {
+        const NumericalScalar x(point[0]);
+        if (x <= 0.0) return 0.0;
+        return sqrt(lambda_ / (2.0 * M_PI * x * x * x)) * exp(- lambda_ * (x - mu_) * (x - mu_) / (2.0 * x * mu_ * mu_));
+      }
+
+      /* Get the CDF of the distribution */
+      NumericalScalar InverseNormal::computeCDF(const NumericalPoint & point, const Bool tail) const
+      {
+        const NumericalScalar x(point[0]);
+        if (x <= 0.0) return (tail ? 1.0 : 0.0);
+        const NumericalScalar lx(sqrt(lambda_ / x));
+        const NumericalScalar phiArg1(lx * ( x / mu_ - 1.0));
+        const NumericalScalar phiArg2(- lx * ( x / mu_ + 1.0));
+        const NumericalScalar result(DistFunc::pNormal(phiArg1) + exp(2.0 * lambda_ / mu_) * DistFunc::pNormal(phiArg2));
+        return (tail ? 1.0 - result : result);
+      }
+
+      /* Get the mean of the distribution */
+      InverseNormal::NumericalPoint InverseNormal::getMean() const /* throw(NotDefinedException) */
+      {
+        return NumericalPoint(1, mu_);
+      }
+
+      /* Get the skewness of the distribution */
+      InverseNormal::NumericalPoint InverseNormal::getSkewness() const /* throw(NotDefinedException) */
+      {
+        return NumericalPoint(1, 3.0 * sqrt(mu_ / lambda_));
+      }
+
+      /* Get the kurtosis of the distribution */
+      InverseNormal::NumericalPoint InverseNormal::getKurtosis() const /* throw(NotDefinedException) */
+      {
+        return NumericalPoint(1, 15.0 * mu_ / lambda_);
+      }
+
+      /* Interface specific to InverseNormal */
+
+      void InverseNormal::setLambdaMu(const NumericalScalar lambda,
+                                      const NumericalScalar mu)
+        /* throw (InvalidArgumentException) */
+      {
+        if ( (lambda <= 0.0) || (mu <= 0.0) ) throw InvalidArgumentException(HERE) << "lambda and mu MUST be positive";
+        lambda_ = lambda;
+        mu_ = mu;
+        computeRange();
+      }
+
+      /* lambda accessor */
+      NumericalScalar InverseNormal::getLambda() const
+      {
+        return lambda_;
+      }
+
+
+      /* mu accessor */
+      NumericalScalar InverseNormal::getMu() const
+      {
+        return mu_;
+      }
+
+      /* Method save() stores the object through the StorageManager */
+      void InverseNormal::save(StorageManager::Advocate & adv) const
+      {
+        NonEllipticalDistribution::save(adv);
+        adv.saveAttribute( "lambda_", lambda_ );
+        adv.saveAttribute( "mu_", mu_ );
+      }
+
+      /* Method load() reloads the object from the StorageManager */
+      void InverseNormal::load(StorageManager::Advocate & adv)
+      {
+        NonEllipticalDistribution::load(adv);
+        adv.loadAttribute( "lambda_", lambda_ );
+        adv.loadAttribute( "mu_", mu_ );
+        computeRange();
+      }
+
+
+    } /* namespace Distribution */
+  } /* namespace Uncertainty */
+} /* namespace OpenTURNS */
diff --git a/lib/src/Uncertainty/Distribution/InverseNormal.hxx b/lib/src/Uncertainty/Distribution/InverseNormal.hxx
new file mode 100644
index 0000000..aa33692
--- /dev/null
+++ b/lib/src/Uncertainty/Distribution/InverseNormal.hxx
@@ -0,0 +1,127 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  InverseNormal.hxx
+ *  @brief The InverseNormal distribution
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy$
+ *  @date:   $LastChangedDate$
+ *  Id:      $Id$
+ */
+#ifndef OPENTURNS_INVERSENORMAL_HXX
+#define OPENTURNS_INVERSENORMAL_HXX
+
+#include "OTprivate.hxx"
+#include "NonEllipticalDistribution.hxx"
+
+namespace OpenTURNS {
+
+  namespace Uncertainty {
+
+    namespace Distribution {
+
+
+      /**
+       * @class InverseNormal
+       *
+       * The InverseNormal distribution.
+       */
+      class InverseNormal
+        : public Model::NonEllipticalDistribution
+      {
+        CLASSNAME;
+      public:
+
+        typedef Base::Common::InvalidArgumentException               InvalidArgumentException;
+        typedef Model::NonEllipticalDistribution                     NonEllipticalDistribution;  // required by SWIG
+        typedef NonEllipticalDistribution::NumericalPoint            NumericalPoint;
+        typedef NonEllipticalDistribution::StorageManager            StorageManager;
+
+        /** Default constructor */
+        InverseNormal();
+
+        /** Parameters constructor */
+        InverseNormal(const NumericalScalar lambda,
+                      const NumericalScalar mu)
+          /* throw (InvalidArgumentException) */;
+
+
+        /** Comparison operator */
+        Bool operator ==(const InverseNormal & other) const;
+
+        /** String converter */
+        String __repr__() const;
+
+
+        /* Interface inherited from Distribution */
+
+        /** Virtual constructor */
+        InverseNormal * clone() const;
+
+        /** Get one realization of the InverseNormal distribution */
+        NumericalPoint getRealization() const;
+
+        /** Get the PDF of the InverseNormal distribution */
+        using NonEllipticalDistribution::computePDF;
+        NumericalScalar computePDF(const NumericalPoint & point) const;
+
+        /** Get the CDF of the InverseNormal distribution */
+        using NonEllipticalDistribution::computeCDF;
+        NumericalScalar computeCDF(const NumericalPoint & point, const Bool tail = false) const;
+
+        /** Get the mean of the distribution */
+        NumericalPoint getMean() const /* throw(NotDefinedException) */;
+
+        /** Get the skewness of the distribution */
+        NumericalPoint getSkewness() const /* throw(NotDefinedException) */;
+
+        /** Get the kurtosis of the distribution */
+        NumericalPoint getKurtosis() const /* throw(NotDefinedException) */;
+
+        /* Interface specific to InverseNormal */
+        void setLambdaMu(const NumericalScalar lambda,
+                    const NumericalScalar mu)
+          /* throw (InvalidArgumentException) */;
+        /** lambda accessor */
+        NumericalScalar getLambda() const;
+
+        /** mu accessor */
+        NumericalScalar getMu() const;
+
+        /** Method save() stores the object through the StorageManager */
+        void save(StorageManager::Advocate & adv) const;
+
+        /** Method load() reloads the object from the StorageManager */
+        void load(StorageManager::Advocate & adv);
+
+      protected:
+
+      private:
+
+        /** The main parameter set of the distribution */
+        NumericalScalar lambda_;
+        NumericalScalar mu_;
+
+      }; /* class InverseNormal */
+
+
+    } /* namespace Distribution */
+  } /* namespace Uncertainty */
+} /* namespace OpenTURNS */
+
+#endif /* OPENTURNS_INVERSENORMAL_HXX */
diff --git a/lib/src/Uncertainty/Distribution/Makefile.am b/lib/src/Uncertainty/Distribution/Makefile.am
index 910e51a..2ef59c1 100644
--- a/lib/src/Uncertainty/Distribution/Makefile.am
+++ b/lib/src/Uncertainty/Distribution/Makefile.am
@@ -120,7 +120,8 @@ otinclude_HEADERS = \
 	KernelSmoothing.hxx \
 	KernelMixture.hxx \
 	Rayleigh.hxx \
-	RayleighFactory.hxx
+	RayleighFactory.hxx \
+	InverseNormal.hxx
 
 noinst_LTLIBRARIES     = libOTDistribution.la
 libOTDistribution_la_CPPFLAGS = $(OT_CPPFLAGS)
@@ -201,6 +202,7 @@ libOTDistribution_la_SOURCES = \
 	KernelSmoothing.cxx \
 	KernelMixture.cxx \
 	Rayleigh.cxx \
-	RayleighFactory.cxx
+	RayleighFactory.cxx \
+	InverseNormal.cxx
 
 EXTRA_DIST = CMakeLists.txt
diff --git a/lib/test/Makefile.am b/lib/test/Makefile.am
index 5ccb500..c13e9b0 100644
--- a/lib/test/Makefile.am
+++ b/lib/test/Makefile.am
@@ -260,6 +260,7 @@ CHECK_TESTS += $(srcdir)/t_DistFunc_normal.at
 CHECK_TESTS += $(srcdir)/t_DistFunc_poisson.at
 CHECK_TESTS += $(srcdir)/t_DistFunc_student.at
 CHECK_TESTS += $(srcdir)/t_Distributions_draw.at
+CHECK_TESTS += $(srcdir)/t_InverseNormal_std.at
 
 ## Model
 CHECK_TESTS += $(srcdir)/t_RandomVector_constant.at
@@ -516,6 +517,7 @@ OUTFILES += $(srcdir)/t_DistFunc_normal.expout
 OUTFILES += $(srcdir)/t_DistFunc_poisson.expout
 OUTFILES += $(srcdir)/t_DistFunc_student.expout
 OUTFILES += $(srcdir)/t_Distributions_draw.expout
+OUTFILES += $(srcdir)/t_InverseNormal_std.expout
 
 ## Model
 OUTFILES += $(srcdir)/t_RandomVector_constant.expout
@@ -778,6 +780,7 @@ CHECK_PROGS += t_DistFunc_normal
 CHECK_PROGS += t_DistFunc_poisson
 CHECK_PROGS += t_DistFunc_student
 CHECK_PROGS += t_Distributions_draw
+CHECK_PROGS += t_InverseNormal_std
 
 ## IsoProbabilisticTransformation
 CHECK_PROGS += t_MarginalTransformationEvaluation_std
@@ -1750,6 +1753,7 @@ t_DistFunc_noncentralstudent_SOURCES                               = t_DistFunc_
 t_DistFunc_normal_SOURCES                                          = t_DistFunc_normal.cxx
 t_DistFunc_poisson_SOURCES                                         = t_DistFunc_poisson.cxx
 t_DistFunc_student_SOURCES                                         = t_DistFunc_student.cxx
+t_InverseNormal_std_SOURCES                                        = t_InverseNormal_std.cxx
 
 examplesSources += $(t_Beta_std_SOURCES)
 examplesSources += $(t_BetaFactory_std_SOURCES)
@@ -1813,6 +1817,7 @@ examplesSources += $(t_UserDefinedFactory_std_SOURCES)
 examplesSources += $(t_Weibull_std_SOURCES)
 examplesSources += $(t_WeibullFactory_std_SOURCES)
 examplesSources += $(t_Distributions_draw_SOURCES)
+examplesSources += $(t_InverseNormal_std_SOURCES)
 
 ## IsoProbabilisticTransformation
 t_MarginalTransformationEvaluation_std_SOURCES                     = t_MarginalTransformationEvaluation_std.cxx
diff --git a/lib/test/check_testsuite.at b/lib/test/check_testsuite.at
index 7261c7c..476f469 100644
--- a/lib/test/check_testsuite.at
+++ b/lib/test/check_testsuite.at
@@ -208,6 +208,7 @@ m4_include(t_DistFunc_normal.at)
 m4_include(t_DistFunc_poisson.at)
 m4_include(t_DistFunc_student.at)
 m4_include(t_Distributions_draw.at)
+m4_include(t_InverseNormal_std.at)
 
 # Model
 m4_include(t_RandomVector_constant.at)
diff --git a/lib/test/t_InverseNormal_std.at b/lib/test/t_InverseNormal_std.at
new file mode 100644
index 0000000..7726a01
--- /dev/null
+++ b/lib/test/t_InverseNormal_std.at
@@ -0,0 +1,14 @@
+AT_SETUP([InverseNormal])
+
+AT_KEYWORDS([std Uncertainty Distribution InverseNormal])
+
+#AT_TESTED([t_InverseNormal_std])
+
+AT_CHECK([cp $abs_srcdir/t_InverseNormal_std.expout expout],[0],[ignore],[ignore])
+
+AT_CHECK([t_InverseNormal_std],
+         [0],
+         [expout],
+         [ignore])
+
+AT_CLEANUP
diff --git a/lib/test/t_InverseNormal_std.cxx b/lib/test/t_InverseNormal_std.cxx
new file mode 100644
index 0000000..ace7d3d
--- /dev/null
+++ b/lib/test/t_InverseNormal_std.cxx
@@ -0,0 +1,147 @@
+//                                               -*- C++ -*-
+/**
+ *  @file  t_InverseNormal_std.cxx
+ *  @brief The test file of class InverseNormal for standard methods
+ *
+ *  (C) Copyright 2005-2010 EDF-EADS-Phimeca
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License.
+ *
+ *  This library is distributed in the hope that it will be useful
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ *  @author: $LastChangedBy$
+ *  @date:   $LastChangedDate$
+ *  Id:      $Id$
+ */
+#include <iostream>
+#include <sstream>
+#include "OT.hxx"
+#include "OTtestcode.hxx"
+#include "OStream.hxx"
+#include "InverseNormal.hxx"
+#include "NumericalPoint.hxx"
+#include "NumericalSample.hxx"
+#include "Graph.hxx"
+#include "FittingTest.hxx"
+
+using namespace OT;
+using namespace OT::Test;
+using namespace OT::Base::Common;
+using namespace OT::Base::Graph;
+using namespace OT::Base::Type;
+using namespace OT::Base::Stat;
+using namespace OT::Uncertainty::StatTest;
+using namespace OT::Uncertainty::Distribution;
+
+
+class TestObject : public InverseNormal
+{
+public:
+  explicit TestObject() : InverseNormal(0.5, 2.) {}
+  explicit TestObject(const String & name) : InverseNormal(0.5, 2.) {setName(name);}
+  virtual ~TestObject() {}
+};
+
+
+int main(int argc, char *argv[])
+{
+  TESTPREAMBLE;
+  OStream fullprint(std::cout);
+  setRandomGenerator();
+
+  try {
+    // Test basic functionnalities
+    checkClassWithClassName<TestObject>();
+
+    // Test some extra functionnalities
+    checkNameFeature<TestObject>();
+
+    // Instanciate one distribution object
+    //InverseNormal distribution(0.5, 2.);
+    InverseNormal distribution(1., 1.);
+    fullprint << "Distribution " << distribution << std::endl;
+
+    Graph graphCDF(distribution.drawCDF(-10.0, 10.0));
+    graphCDF.draw("inversenormalCDF");
+
+    Graph graphPDF(distribution.drawPDF(0.0, 3.0));
+    graphPDF.draw("inversenormalPDF");
+
+    // Is this distribution elliptical ?
+    fullprint << "Elliptical = " << (distribution.isElliptical() ? "true" : "false") << std::endl;
+
+    // Is this distribution continuous ?
+    fullprint << "Continuous = " << (distribution.isContinuous() ? "true" : "false") << std::endl;
+
+    fullprint << "range=" << distribution.getRange() << std::endl;
+
+    // Test for realization of distribution
+    NumericalPoint oneRealization = distribution.getRealization();
+    fullprint << "oneRealization=" << oneRealization << std::endl;
+
+    // Test for sampling
+    UnsignedLong size = 100000;
+    NumericalSample oneSample = distribution.getNumericalSample( size );
+    fullprint << "oneSample first=" << oneSample[0] << " last=" << oneSample[size - 1] << std::endl;
+    fullprint << "mean=" << oneSample.computeMean() << std::endl;
+    fullprint << "covariance=" << oneSample.computeCovariance() << std::endl;
+
+    // Test for sampling
+    NumericalSample otherSample = distribution.getNumericalSample( size );
+    FittingTest::TestResult result = FittingTest::Kolmogorov(otherSample, distribution, 0.9);
+    fullprint << "kolmogorov? " << result << std::endl;
+
+    // Define a point, left part of the support
+    NumericalPoint point( distribution.getDimension(), 0.1 );
+    fullprint << "Point= " << point << std::endl;
+
+    // Show CDF of point
+    NumericalScalar eps(1e-5);
+    NumericalScalar CDF = distribution.computeCDF( point );
+    fullprint << "cdf=" << CDF << std::endl;
+    NumericalPoint quantile = distribution.computeQuantile( 0.25 );
+    fullprint << "quantile=" << quantile << std::endl;
+    fullprint << "cdf(quantile)=" << distribution.computeCDF(quantile) << std::endl;
+    // Define a point, right part of the support
+    point = NumericalPoint( distribution.getDimension(), 2.0 );
+    fullprint << "Point= " << point << std::endl;
+
+    // Show PDF and CDF of point
+    CDF = distribution.computeCDF( point );
+    fullprint << "cdf=" << CDF << std::endl;
+    fullprint << "quantile=" << quantile << std::endl;
+    fullprint << "cdf(quantile)=" << distribution.computeCDF(quantile) << std::endl;
+
+/*
+    Study myStudy;
+    myStudy.setStorageManager(XMLStorageManager("testStudy.ot"));
+    myStudy.add("distribution", distribution);
+    myStudy.save();
+
+    Study myStudy2;
+    myStudy2.setStorageManager(XMLStorageManager("testStudy.ot"));
+    myStudy2.load();
+    InverseNormal inverseNormal;
+    myStudy2.fillObject("distribution", inverseNormal);
+    fullprint << "loaded InverseNormal=" << inverseNormal << std::endl;
+*/
+
+  }
+  catch (TestFailed & ex) {
+    std::cerr << ex << std::endl;
+    return ExitCode::Error;
+  }
+
+
+  return ExitCode::Success;
+}
diff --git a/lib/test/t_InverseNormal_std.expout b/lib/test/t_InverseNormal_std.expout
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/lib/test/t_InverseNormal_std.expout
@@ -0,0 +1 @@
+
diff --git a/python/src/InverseNormal.i b/python/src/InverseNormal.i
new file mode 100644
index 0000000..ff1f452
--- /dev/null
+++ b/python/src/InverseNormal.i
@@ -0,0 +1,11 @@
+// SWIG file InverseNormal.i
+// Author : $LastChangedBy$
+// Date : $LastChangedDate$
+// Id : $Id$
+
+%{
+#include "InverseNormal.hxx"
+%}
+
+%include InverseNormal.hxx
+namespace OpenTURNS { namespace Uncertainty { namespace Distribution { %extend InverseNormal { InverseNormal(const InverseNormal & other) { return new OpenTURNS::Uncertainty::Distribution::InverseNormal(other); } } }}}
diff --git a/python/src/Makefile.am b/python/src/Makefile.am
index 046fbf9..9047f80 100644
--- a/python/src/Makefile.am
+++ b/python/src/Makefile.am
@@ -669,6 +669,7 @@ OPENTURNS_MODEL_DIST_SWIG_SRC = \
 	NonCentralStudent.i \
 	Normal.i \
 	NormalFactory.i \
+	InverseNormal.i \
 	Poisson.i \
 	PoissonFactory.i \
 	Rayleigh.i \
diff --git a/python/src/model_dist.i b/python/src/model_dist.i
index 3b91ead..d91ffe8 100644
--- a/python/src/model_dist.i
+++ b/python/src/model_dist.i
@@ -61,6 +61,7 @@
 %include HistogramPair.i
 %include Histogram.i
 %include HistogramFactory.i
+%include InverseNormal.i
 %include Laplace.i
 %include LaplaceFactory.i
 %include LogNormal.i
diff --git a/python/test/Makefile.am b/python/test/Makefile.am
index 0a26ae6..4bd78a4 100644
--- a/python/test/Makefile.am
+++ b/python/test/Makefile.am
@@ -223,6 +223,7 @@ PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_HistogramFactory_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_KernelMixture_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_KernelSmoothing_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_IndependentCopula_std.atpy
+PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_InverseNormal_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_Laplace_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_LaplaceFactory_std.atpy
 PYTHONINSTALLCHECK_TESTS += $(srcdir)/t_LogNormal_std.atpy
@@ -835,6 +836,7 @@ PYTHONINSTALLCHECK_PROGS += t_GumbelCopulaFactory_std.py
 PYTHONINSTALLCHECK_PROGS += t_Histogram_std.py
 PYTHONINSTALLCHECK_PROGS += t_HistogramFactory_std.py
 PYTHONINSTALLCHECK_PROGS += t_IndependentCopula_std.py
+PYTHONINSTALLCHECK_PROGS += t_InverseNormal_std.py
 PYTHONINSTALLCHECK_PROGS += t_Laplace_std.py
 PYTHONINSTALLCHECK_PROGS += t_LaplaceFactory_std.py
 PYTHONINSTALLCHECK_PROGS += t_LogNormal_std.py
diff --git a/python/test/python_installcheck_testsuite.at b/python/test/python_installcheck_testsuite.at
index 058641f..3269229 100644
--- a/python/test/python_installcheck_testsuite.at
+++ b/python/test/python_installcheck_testsuite.at
@@ -200,6 +200,7 @@ m4_include(t_GumbelCopula_std.atpy)
 m4_include(t_GumbelCopulaFactory_std.atpy)
 m4_include(t_Histogram_std.atpy)
 m4_include(t_HistogramFactory_std.atpy)
+m4_include(t_InverseNormal_std.atpy)
 m4_include(t_KernelMixture_std.atpy)
 m4_include(t_KernelSmoothing_std.atpy)
 m4_include(t_IndependentCopula_std.atpy)
diff --git a/python/test/t_InverseNormal_std.atpy b/python/test/t_InverseNormal_std.atpy
new file mode 100644
index 0000000..e0eb800
--- /dev/null
+++ b/python/test/t_InverseNormal_std.atpy
@@ -0,0 +1,14 @@
+AT_SETUP([InverseNormal])
+
+AT_KEYWORDS([std Uncertainty Distribution InverseNormal NumericalSample])
+
+#AT_TESTED([t_InverseNormal_std.py])
+
+AT_CHECK([cp $abs_srcdir/t_InverseNormal_std.expout expout],[0],[ignore],[ignore])
+
+AT_CHECK([python ${examplesdir}/t_InverseNormal_std.py],
+         [0],
+         [expout],
+         [ignore])
+
+AT_CLEANUP
diff --git a/python/test/t_InverseNormal_std.expout b/python/test/t_InverseNormal_std.expout
new file mode 100644
index 0000000..e69de29
diff --git a/python/test/t_InverseNormal_std.py b/python/test/t_InverseNormal_std.py
new file mode 100755
index 0000000..a92020c
--- /dev/null
+++ b/python/test/t_InverseNormal_std.py
@@ -0,0 +1,136 @@
+#! /usr/bin/env python
+
+from openturns import *
+from math import *
+
+TESTPREAMBLE()
+RandomGenerator().SetSeed(0)
+
+def cleanScalar(inScalar) :
+  if (fabs(inScalar) < 1.e-10) :
+    inScalar = 0.0
+  return inScalar
+
+def cleanNumericalPoint(inNumericalPoint) :
+  dim = inNumericalPoint.getDimension()
+  for i in range(dim) :
+    if (fabs(inNumericalPoint[i]) < 1.e-10) :
+      inNumericalPoint[i] = 0.0
+  return inNumericalPoint
+
+
+def cleanMatrix(inMatrix) :
+  rowDim = inMatrix.getNbRows()
+  colDim = inMatrix.getNbColumns()
+  for i in range(rowDim) :
+    for j in range(colDim) :
+      if (fabs(inMatrix[i, j]) < 1.e-10) :
+        inMatrix[i, j] = 0.0
+  return inMatrix
+
+
+try :
+  PlatformInfo.SetNumericalPrecision(5)
+  # Instanciate one distribution object
+  dim = 1
+  distLambda = 1.0
+  distMu = 1.0
+
+  distribution = InverseNormal(distLambda, distMu)
+
+  distribution.setName("An inverse normal distribution")
+
+  print "Parameters collection=", repr(distribution.getParametersCollection())
+  print "Distribution ", repr(distribution)
+  print "Covariance ", repr(distribution.getCovariance())
+
+  # Is this distribution elliptical ?
+  print "Elliptical = ", distribution.isElliptical()
+
+  # Is this distribution continuous ?
+  print "Continuous = ", distribution.isContinuous()
+
+  # Test for realization of distribution
+  oneRealization = distribution.getRealization()
+  print "oneRealization=", repr(oneRealization)
+
+  # Test for sampling
+  size = 100000
+  oneSample = distribution.getNumericalSample( size )
+  print "oneSample first=" , repr(oneSample[0]) , " last=" , repr(oneSample[size - 1])
+  print "mean=" , repr(oneSample.computeMean())
+  print "covariance=" , repr(oneSample.computeCovariance())
+
+  # Define a point
+  point = NumericalPoint( distribution.getDimension(), 0.5 )
+  print "Point= " , repr(point)
+
+  # Show PDF and CDF of point
+  eps = 1e-5
+
+#  # derivative of PDF with regards its arguments
+#  DDF = distribution.computeDDF( point )
+#  print "ddf     =" , repr(cleanNumericalPoint(DDF))
+#  # by the finite difference technique
+#  ddfFD = NumericalPoint(dim)
+#  for i in range(dim) :
+#    pointEps = point
+#    pointEps[i] += eps
+#    ddfFD[i] = distribution.computePDF(pointEps)
+#    pointEps[i] -= 2.0 * eps
+#    ddfFD[i] -= distribution.computePDF(pointEps)
+#    ddfFD[i] /= 2.0 * eps
+#  print "ddf (FD)=" , repr(cleanNumericalPoint(ddfFD))
+# 
+#  # PDF value
+#  PDF = distribution.computePDF( point )
+#  print "pdf     =%.6f" % PDF
+#  # by the finite difference technique from CDF
+#  if dim == 1 :
+#    print "pdf (FD)=%.6f" % cleanScalar((distribution.computeCDF( point + NumericalPoint(1, eps) ) - distribution.computeCDF( point  + NumericalPoint(1, -eps) )) / (2.0 * eps))
+# 
+#  # derivative of the PDF with regards the parameters of the distribution
+#  CDF = distribution.computeCDF( point )
+#  print "cdf=%.6f" % CDF
+#  PDFgr = distribution.computePDFGradient( point )
+#  print "pdf gradient     =" , repr(PDFgr)
+#  # by the finite difference technique
+#  PDFgrFD = NumericalPoint(2 * dim)
+#  distLambda += eps
+#  distributionLeft = InverseNormal(distLambda, distMu)
+#  distLambda -= 2.0 * eps
+#  distributionRight = InverseNormal(distLambda, distMu)
+#  PDFgrFD = (distributionLeft.computePDF(point) - distributionRight.computePDF(point)) / (2.0 * eps)
+#  distLambda += eps
+#  distMu += eps
+#  distributionLeft = InverseNormal(distLambda, distMu)
+#  distMu -= 2.0 * eps
+#  distributionRight = InverseNormal(distLambda, distMu)
+#  PDFgrFD[dim] = (distributionLeft.computePDF(point) - distributionRight.computePDF(point)) / (2.0 * eps)
+#  distMu += eps
+#  print "pdf gradient (FD)=" , repr(cleanNumericalPoint(PDFgrFD))
+# 
+#  # derivative of the PDF with regards the parameters of the distribution
+#  #   CDFgr = distribution.computeCDFGradient( point )
+#  #     print "cdf gradient     =" , CDFgr
+# 
+#  # quantile
+#  quantile = distribution.computeQuantile( 0.95 )
+#  print "quantile=" , repr(quantile)
+#  print "cdf(quantile)=%.6f" % distribution.computeCDF(quantile)
+#  mean = distribution.getMean()
+#  print "mean=" , repr(mean)
+#  standardDeviation = distribution.getStandardDeviation()
+#  print "standard deviation=" , repr(standardDeviation)
+#  skewness = distribution.getSkewness()
+#  print "skewness=" , repr(skewness)
+#  kurtosis = distribution.getKurtosis()
+#  print "kurtosis=" , repr(kurtosis)
+#  covariance = distribution.getCovariance()
+#  print "covariance=" , repr(covariance)
+#  parameters = distribution.getParametersCollection()
+#  print "parameters=" , repr(parameters)
+
+except :
+  import sys
+  print "t_InverseNormal_std.py", sys.exc_type, sys.exc_value